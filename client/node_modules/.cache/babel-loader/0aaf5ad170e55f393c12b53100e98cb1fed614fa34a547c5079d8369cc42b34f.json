{"ast":null,"code":"/*!\nFullCalendar v5.11.5\nDocs & License: https://fullcalendar.io/\n(c) 2022 Adam Shaw\n*/\nimport './main.css';\nimport { hasBgRendering, Splitter, createFormatter, createElement, ViewContextType, RenderHook, BaseComponent, createRef, diffDays, buildNavLinkAttrs, WeekNumberRoot, getStickyHeaderDates, ViewRoot, SimpleScrollGrid, getStickyFooterScrollbar, NowTimer, NowIndicatorRoot, renderScrollShim, DateComponent, rangeContainsMarker, startOfDay, asRoughMs, createDuration, RefMap, PositionCache, MoreLinkRoot, setRef, SegHierarchy, groupIntersectingEntries, buildEntryKey, binarySearch, getEntrySpanEnd, StandardEvent, DayCellContent, Fragment, getSegMeta, memoize, sortEventSegs, DayCellRoot, buildIsoString, computeEarliestSegStart, buildEventRangeKey, BgEvent, renderFill, addDurations, multiplyDuration, wholeDivideDurations, intersectRanges, Slicer, formatIsoTimeString, DayHeader, DaySeriesModel, DayTableModel, createPlugin } from '@fullcalendar/common';\nimport { __extends, __assign } from 'tslib';\nimport { DayTable } from '@fullcalendar/daygrid';\nvar AllDaySplitter = /** @class */function (_super) {\n  __extends(AllDaySplitter, _super);\n  function AllDaySplitter() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  AllDaySplitter.prototype.getKeyInfo = function () {\n    return {\n      allDay: {},\n      timed: {}\n    };\n  };\n  AllDaySplitter.prototype.getKeysForDateSpan = function (dateSpan) {\n    if (dateSpan.allDay) {\n      return ['allDay'];\n    }\n    return ['timed'];\n  };\n  AllDaySplitter.prototype.getKeysForEventDef = function (eventDef) {\n    if (!eventDef.allDay) {\n      return ['timed'];\n    }\n    if (hasBgRendering(eventDef)) {\n      return ['timed', 'allDay'];\n    }\n    return ['allDay'];\n  };\n  return AllDaySplitter;\n}(Splitter);\nvar DEFAULT_SLAT_LABEL_FORMAT = createFormatter({\n  hour: 'numeric',\n  minute: '2-digit',\n  omitZeroMinute: true,\n  meridiem: 'short'\n});\nfunction TimeColsAxisCell(props) {\n  var classNames = ['fc-timegrid-slot', 'fc-timegrid-slot-label', props.isLabeled ? 'fc-scrollgrid-shrink' : 'fc-timegrid-slot-minor'];\n  return createElement(ViewContextType.Consumer, null, function (context) {\n    if (!props.isLabeled) {\n      return createElement(\"td\", {\n        className: classNames.join(' '),\n        \"data-time\": props.isoTimeStr\n      });\n    }\n    var dateEnv = context.dateEnv,\n      options = context.options,\n      viewApi = context.viewApi;\n    var labelFormat =\n    // TODO: fully pre-parse\n    options.slotLabelFormat == null ? DEFAULT_SLAT_LABEL_FORMAT : Array.isArray(options.slotLabelFormat) ? createFormatter(options.slotLabelFormat[0]) : createFormatter(options.slotLabelFormat);\n    var hookProps = {\n      level: 0,\n      time: props.time,\n      date: dateEnv.toDate(props.date),\n      view: viewApi,\n      text: dateEnv.format(props.date, labelFormat)\n    };\n    return createElement(RenderHook, {\n      hookProps: hookProps,\n      classNames: options.slotLabelClassNames,\n      content: options.slotLabelContent,\n      defaultContent: renderInnerContent,\n      didMount: options.slotLabelDidMount,\n      willUnmount: options.slotLabelWillUnmount\n    }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n      return createElement(\"td\", {\n        ref: rootElRef,\n        className: classNames.concat(customClassNames).join(' '),\n        \"data-time\": props.isoTimeStr\n      }, createElement(\"div\", {\n        className: \"fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame\"\n      }, createElement(\"div\", {\n        className: \"fc-timegrid-slot-label-cushion fc-scrollgrid-shrink-cushion\",\n        ref: innerElRef\n      }, innerContent)));\n    });\n  });\n}\nfunction renderInnerContent(props) {\n  return props.text;\n}\nvar TimeBodyAxis = /** @class */function (_super) {\n  __extends(TimeBodyAxis, _super);\n  function TimeBodyAxis() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  TimeBodyAxis.prototype.render = function () {\n    return this.props.slatMetas.map(function (slatMeta) {\n      return createElement(\"tr\", {\n        key: slatMeta.key\n      }, createElement(TimeColsAxisCell, __assign({}, slatMeta)));\n    });\n  };\n  return TimeBodyAxis;\n}(BaseComponent);\nvar DEFAULT_WEEK_NUM_FORMAT = createFormatter({\n  week: 'short'\n});\nvar AUTO_ALL_DAY_MAX_EVENT_ROWS = 5;\nvar TimeColsView = /** @class */function (_super) {\n  __extends(TimeColsView, _super);\n  function TimeColsView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.allDaySplitter = new AllDaySplitter(); // for use by subclasses\n    _this.headerElRef = createRef();\n    _this.rootElRef = createRef();\n    _this.scrollerElRef = createRef();\n    _this.state = {\n      slatCoords: null\n    };\n    _this.handleScrollTopRequest = function (scrollTop) {\n      var scrollerEl = _this.scrollerElRef.current;\n      if (scrollerEl) {\n        // TODO: not sure how this could ever be null. weirdness with the reducer\n        scrollerEl.scrollTop = scrollTop;\n      }\n    };\n    /* Header Render Methods\n    ------------------------------------------------------------------------------------------------------------------*/\n    _this.renderHeadAxis = function (rowKey, frameHeight) {\n      if (frameHeight === void 0) {\n        frameHeight = '';\n      }\n      var options = _this.context.options;\n      var dateProfile = _this.props.dateProfile;\n      var range = dateProfile.renderRange;\n      var dayCnt = diffDays(range.start, range.end);\n      var navLinkAttrs = dayCnt === 1 // only do in day views (to avoid doing in week views that dont need it)\n      ? buildNavLinkAttrs(_this.context, range.start, 'week') : {};\n      if (options.weekNumbers && rowKey === 'day') {\n        return createElement(WeekNumberRoot, {\n          date: range.start,\n          defaultFormat: DEFAULT_WEEK_NUM_FORMAT\n        }, function (rootElRef, classNames, innerElRef, innerContent) {\n          return createElement(\"th\", {\n            ref: rootElRef,\n            \"aria-hidden\": true,\n            className: ['fc-timegrid-axis', 'fc-scrollgrid-shrink'].concat(classNames).join(' ')\n          }, createElement(\"div\", {\n            className: \"fc-timegrid-axis-frame fc-scrollgrid-shrink-frame fc-timegrid-axis-frame-liquid\",\n            style: {\n              height: frameHeight\n            }\n          }, createElement(\"a\", __assign({\n            ref: innerElRef,\n            className: \"fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner\"\n          }, navLinkAttrs), innerContent)));\n        });\n      }\n      return createElement(\"th\", {\n        \"aria-hidden\": true,\n        className: \"fc-timegrid-axis\"\n      }, createElement(\"div\", {\n        className: \"fc-timegrid-axis-frame\",\n        style: {\n          height: frameHeight\n        }\n      }));\n    };\n    /* Table Component Render Methods\n    ------------------------------------------------------------------------------------------------------------------*/\n    // only a one-way height sync. we don't send the axis inner-content height to the DayGrid,\n    // but DayGrid still needs to have classNames on inner elements in order to measure.\n    _this.renderTableRowAxis = function (rowHeight) {\n      var _a = _this.context,\n        options = _a.options,\n        viewApi = _a.viewApi;\n      var hookProps = {\n        text: options.allDayText,\n        view: viewApi\n      };\n      return (\n        // TODO: make reusable hook. used in list view too\n        createElement(RenderHook, {\n          hookProps: hookProps,\n          classNames: options.allDayClassNames,\n          content: options.allDayContent,\n          defaultContent: renderAllDayInner,\n          didMount: options.allDayDidMount,\n          willUnmount: options.allDayWillUnmount\n        }, function (rootElRef, classNames, innerElRef, innerContent) {\n          return createElement(\"td\", {\n            ref: rootElRef,\n            \"aria-hidden\": true,\n            className: ['fc-timegrid-axis', 'fc-scrollgrid-shrink'].concat(classNames).join(' ')\n          }, createElement(\"div\", {\n            className: 'fc-timegrid-axis-frame fc-scrollgrid-shrink-frame' + (rowHeight == null ? ' fc-timegrid-axis-frame-liquid' : ''),\n            style: {\n              height: rowHeight\n            }\n          }, createElement(\"span\", {\n            className: \"fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner\",\n            ref: innerElRef\n          }, innerContent)));\n        })\n      );\n    };\n    _this.handleSlatCoords = function (slatCoords) {\n      _this.setState({\n        slatCoords: slatCoords\n      });\n    };\n    return _this;\n  }\n  // rendering\n  // ----------------------------------------------------------------------------------------------------\n  TimeColsView.prototype.renderSimpleLayout = function (headerRowContent, allDayContent, timeContent) {\n    var _a = this,\n      context = _a.context,\n      props = _a.props;\n    var sections = [];\n    var stickyHeaderDates = getStickyHeaderDates(context.options);\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        chunk: {\n          elRef: this.headerElRef,\n          tableClassName: 'fc-col-header',\n          rowContent: headerRowContent\n        }\n      });\n    }\n    if (allDayContent) {\n      sections.push({\n        type: 'body',\n        key: 'all-day',\n        chunk: {\n          content: allDayContent\n        }\n      });\n      sections.push({\n        type: 'body',\n        key: 'all-day-divider',\n        outerContent:\n        // TODO: rename to cellContent so don't need to define <tr>?\n        createElement(\"tr\", {\n          role: \"presentation\",\n          className: \"fc-scrollgrid-section\"\n        }, createElement(\"td\", {\n          className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')\n        }))\n      });\n    }\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      expandRows: Boolean(context.options.expandRows),\n      chunk: {\n        scrollerElRef: this.scrollerElRef,\n        content: timeContent\n      }\n    });\n    return createElement(ViewRoot, {\n      viewSpec: context.viewSpec,\n      elRef: this.rootElRef\n    }, function (rootElRef, classNames) {\n      return createElement(\"div\", {\n        className: ['fc-timegrid'].concat(classNames).join(' '),\n        ref: rootElRef\n      }, createElement(SimpleScrollGrid, {\n        liquid: !props.isHeightAuto && !props.forPrint,\n        collapsibleWidth: props.forPrint,\n        cols: [{\n          width: 'shrink'\n        }],\n        sections: sections\n      }));\n    });\n  };\n  TimeColsView.prototype.renderHScrollLayout = function (headerRowContent, allDayContent, timeContent, colCnt, dayMinWidth, slatMetas, slatCoords) {\n    var _this = this;\n    var ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n    if (!ScrollGrid) {\n      throw new Error('No ScrollGrid implementation');\n    }\n    var _a = this,\n      context = _a.context,\n      props = _a.props;\n    var stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);\n    var stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);\n    var sections = [];\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        syncRowHeights: true,\n        chunks: [{\n          key: 'axis',\n          rowContent: function (arg) {\n            return createElement(\"tr\", {\n              role: \"presentation\"\n            }, _this.renderHeadAxis('day', arg.rowSyncHeights[0]));\n          }\n        }, {\n          key: 'cols',\n          elRef: this.headerElRef,\n          tableClassName: 'fc-col-header',\n          rowContent: headerRowContent\n        }]\n      });\n    }\n    if (allDayContent) {\n      sections.push({\n        type: 'body',\n        key: 'all-day',\n        syncRowHeights: true,\n        chunks: [{\n          key: 'axis',\n          rowContent: function (contentArg) {\n            return createElement(\"tr\", {\n              role: \"presentation\"\n            }, _this.renderTableRowAxis(contentArg.rowSyncHeights[0]));\n          }\n        }, {\n          key: 'cols',\n          content: allDayContent\n        }]\n      });\n      sections.push({\n        key: 'all-day-divider',\n        type: 'body',\n        outerContent:\n        // TODO: rename to cellContent so don't need to define <tr>?\n        createElement(\"tr\", {\n          role: \"presentation\",\n          className: \"fc-scrollgrid-section\"\n        }, createElement(\"td\", {\n          colSpan: 2,\n          className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')\n        }))\n      });\n    }\n    var isNowIndicator = context.options.nowIndicator;\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      expandRows: Boolean(context.options.expandRows),\n      chunks: [{\n        key: 'axis',\n        content: function (arg) {\n          return (\n            // TODO: make this now-indicator arrow more DRY with TimeColsContent\n            createElement(\"div\", {\n              className: \"fc-timegrid-axis-chunk\"\n            }, createElement(\"table\", {\n              \"aria-hidden\": true,\n              style: {\n                height: arg.expandRows ? arg.clientHeight : ''\n              }\n            }, arg.tableColGroupNode, createElement(\"tbody\", null, createElement(TimeBodyAxis, {\n              slatMetas: slatMetas\n            }))), createElement(\"div\", {\n              className: \"fc-timegrid-now-indicator-container\"\n            }, createElement(NowTimer, {\n              unit: isNowIndicator ? 'minute' : 'day' /* hacky */\n            }, function (nowDate) {\n              var nowIndicatorTop = isNowIndicator && slatCoords && slatCoords.safeComputeTop(nowDate); // might return void\n              if (typeof nowIndicatorTop === 'number') {\n                return createElement(NowIndicatorRoot, {\n                  isAxis: true,\n                  date: nowDate\n                }, function (rootElRef, classNames, innerElRef, innerContent) {\n                  return createElement(\"div\", {\n                    ref: rootElRef,\n                    className: ['fc-timegrid-now-indicator-arrow'].concat(classNames).join(' '),\n                    style: {\n                      top: nowIndicatorTop\n                    }\n                  }, innerContent);\n                });\n              }\n              return null;\n            })))\n          );\n        }\n      }, {\n        key: 'cols',\n        scrollerElRef: this.scrollerElRef,\n        content: timeContent\n      }]\n    });\n    if (stickyFooterScrollbar) {\n      sections.push({\n        key: 'footer',\n        type: 'footer',\n        isSticky: true,\n        chunks: [{\n          key: 'axis',\n          content: renderScrollShim\n        }, {\n          key: 'cols',\n          content: renderScrollShim\n        }]\n      });\n    }\n    return createElement(ViewRoot, {\n      viewSpec: context.viewSpec,\n      elRef: this.rootElRef\n    }, function (rootElRef, classNames) {\n      return createElement(\"div\", {\n        className: ['fc-timegrid'].concat(classNames).join(' '),\n        ref: rootElRef\n      }, createElement(ScrollGrid, {\n        liquid: !props.isHeightAuto && !props.forPrint,\n        collapsibleWidth: false,\n        colGroups: [{\n          width: 'shrink',\n          cols: [{\n            width: 'shrink'\n          }]\n        }, {\n          cols: [{\n            span: colCnt,\n            minWidth: dayMinWidth\n          }]\n        }],\n        sections: sections\n      }));\n    });\n  };\n  /* Dimensions\n  ------------------------------------------------------------------------------------------------------------------*/\n  TimeColsView.prototype.getAllDayMaxEventProps = function () {\n    var _a = this.context.options,\n      dayMaxEvents = _a.dayMaxEvents,\n      dayMaxEventRows = _a.dayMaxEventRows;\n    if (dayMaxEvents === true || dayMaxEventRows === true) {\n      // is auto?\n      dayMaxEvents = undefined;\n      dayMaxEventRows = AUTO_ALL_DAY_MAX_EVENT_ROWS; // make sure \"auto\" goes to a real number\n    }\n    return {\n      dayMaxEvents: dayMaxEvents,\n      dayMaxEventRows: dayMaxEventRows\n    };\n  };\n  return TimeColsView;\n}(DateComponent);\nfunction renderAllDayInner(hookProps) {\n  return hookProps.text;\n}\nvar TimeColsSlatsCoords = /** @class */function () {\n  function TimeColsSlatsCoords(positions, dateProfile, slotDuration) {\n    this.positions = positions;\n    this.dateProfile = dateProfile;\n    this.slotDuration = slotDuration;\n  }\n  TimeColsSlatsCoords.prototype.safeComputeTop = function (date) {\n    var dateProfile = this.dateProfile;\n    if (rangeContainsMarker(dateProfile.currentRange, date)) {\n      var startOfDayDate = startOfDay(date);\n      var timeMs = date.valueOf() - startOfDayDate.valueOf();\n      if (timeMs >= asRoughMs(dateProfile.slotMinTime) && timeMs < asRoughMs(dateProfile.slotMaxTime)) {\n        return this.computeTimeTop(createDuration(timeMs));\n      }\n    }\n    return null;\n  };\n  // Computes the top coordinate, relative to the bounds of the grid, of the given date.\n  // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.\n  TimeColsSlatsCoords.prototype.computeDateTop = function (when, startOfDayDate) {\n    if (!startOfDayDate) {\n      startOfDayDate = startOfDay(when);\n    }\n    return this.computeTimeTop(createDuration(when.valueOf() - startOfDayDate.valueOf()));\n  };\n  // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).\n  // This is a makeshify way to compute the time-top. Assumes all slatMetas dates are uniform.\n  // Eventually allow computation with arbirary slat dates.\n  TimeColsSlatsCoords.prototype.computeTimeTop = function (duration) {\n    var _a = this,\n      positions = _a.positions,\n      dateProfile = _a.dateProfile;\n    var len = positions.els.length;\n    // floating-point value of # of slots covered\n    var slatCoverage = (duration.milliseconds - asRoughMs(dateProfile.slotMinTime)) / asRoughMs(this.slotDuration);\n    var slatIndex;\n    var slatRemainder;\n    // compute a floating-point number for how many slats should be progressed through.\n    // from 0 to number of slats (inclusive)\n    // constrained because slotMinTime/slotMaxTime might be customized.\n    slatCoverage = Math.max(0, slatCoverage);\n    slatCoverage = Math.min(len, slatCoverage);\n    // an integer index of the furthest whole slat\n    // from 0 to number slats (*exclusive*, so len-1)\n    slatIndex = Math.floor(slatCoverage);\n    slatIndex = Math.min(slatIndex, len - 1);\n    // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.\n    // could be 1.0 if slatCoverage is covering *all* the slots\n    slatRemainder = slatCoverage - slatIndex;\n    return positions.tops[slatIndex] + positions.getHeight(slatIndex) * slatRemainder;\n  };\n  return TimeColsSlatsCoords;\n}();\nvar TimeColsSlatsBody = /** @class */function (_super) {\n  __extends(TimeColsSlatsBody, _super);\n  function TimeColsSlatsBody() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  TimeColsSlatsBody.prototype.render = function () {\n    var _a = this,\n      props = _a.props,\n      context = _a.context;\n    var options = context.options;\n    var slatElRefs = props.slatElRefs;\n    return createElement(\"tbody\", null, props.slatMetas.map(function (slatMeta, i) {\n      var hookProps = {\n        time: slatMeta.time,\n        date: context.dateEnv.toDate(slatMeta.date),\n        view: context.viewApi\n      };\n      var classNames = ['fc-timegrid-slot', 'fc-timegrid-slot-lane', slatMeta.isLabeled ? '' : 'fc-timegrid-slot-minor'];\n      return createElement(\"tr\", {\n        key: slatMeta.key,\n        ref: slatElRefs.createRef(slatMeta.key)\n      }, props.axis && createElement(TimeColsAxisCell, __assign({}, slatMeta)), createElement(RenderHook, {\n        hookProps: hookProps,\n        classNames: options.slotLaneClassNames,\n        content: options.slotLaneContent,\n        didMount: options.slotLaneDidMount,\n        willUnmount: options.slotLaneWillUnmount\n      }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n        return createElement(\"td\", {\n          ref: rootElRef,\n          className: classNames.concat(customClassNames).join(' '),\n          \"data-time\": slatMeta.isoTimeStr\n        }, innerContent);\n      }));\n    }));\n  };\n  return TimeColsSlatsBody;\n}(BaseComponent);\n\n/*\nfor the horizontal \"slats\" that run width-wise. Has a time axis on a side. Depends on RTL.\n*/\nvar TimeColsSlats = /** @class */function (_super) {\n  __extends(TimeColsSlats, _super);\n  function TimeColsSlats() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.rootElRef = createRef();\n    _this.slatElRefs = new RefMap();\n    return _this;\n  }\n  TimeColsSlats.prototype.render = function () {\n    var _a = this,\n      props = _a.props,\n      context = _a.context;\n    return createElement(\"div\", {\n      ref: this.rootElRef,\n      className: \"fc-timegrid-slots\"\n    }, createElement(\"table\", {\n      \"aria-hidden\": true,\n      className: context.theme.getClass('table'),\n      style: {\n        minWidth: props.tableMinWidth,\n        width: props.clientWidth,\n        height: props.minHeight\n      }\n    }, props.tableColGroupNode /* relies on there only being a single <col> for the axis */, createElement(TimeColsSlatsBody, {\n      slatElRefs: this.slatElRefs,\n      axis: props.axis,\n      slatMetas: props.slatMetas\n    })));\n  };\n  TimeColsSlats.prototype.componentDidMount = function () {\n    this.updateSizing();\n  };\n  TimeColsSlats.prototype.componentDidUpdate = function () {\n    this.updateSizing();\n  };\n  TimeColsSlats.prototype.componentWillUnmount = function () {\n    if (this.props.onCoords) {\n      this.props.onCoords(null);\n    }\n  };\n  TimeColsSlats.prototype.updateSizing = function () {\n    var _a = this,\n      context = _a.context,\n      props = _a.props;\n    if (props.onCoords && props.clientWidth !== null // means sizing has stabilized\n    ) {\n      var rootEl = this.rootElRef.current;\n      if (rootEl.offsetHeight) {\n        // not hidden by css\n        props.onCoords(new TimeColsSlatsCoords(new PositionCache(this.rootElRef.current, collectSlatEls(this.slatElRefs.currentMap, props.slatMetas), false, true), this.props.dateProfile, context.options.slotDuration));\n      }\n    }\n  };\n  return TimeColsSlats;\n}(BaseComponent);\nfunction collectSlatEls(elMap, slatMetas) {\n  return slatMetas.map(function (slatMeta) {\n    return elMap[slatMeta.key];\n  });\n}\nfunction splitSegsByCol(segs, colCnt) {\n  var segsByCol = [];\n  var i;\n  for (i = 0; i < colCnt; i += 1) {\n    segsByCol.push([]);\n  }\n  if (segs) {\n    for (i = 0; i < segs.length; i += 1) {\n      segsByCol[segs[i].col].push(segs[i]);\n    }\n  }\n  return segsByCol;\n}\nfunction splitInteractionByCol(ui, colCnt) {\n  var byRow = [];\n  if (!ui) {\n    for (var i = 0; i < colCnt; i += 1) {\n      byRow[i] = null;\n    }\n  } else {\n    for (var i = 0; i < colCnt; i += 1) {\n      byRow[i] = {\n        affectedInstances: ui.affectedInstances,\n        isEvent: ui.isEvent,\n        segs: []\n      };\n    }\n    for (var _i = 0, _a = ui.segs; _i < _a.length; _i++) {\n      var seg = _a[_i];\n      byRow[seg.col].segs.push(seg);\n    }\n  }\n  return byRow;\n}\nvar TimeColMoreLink = /** @class */function (_super) {\n  __extends(TimeColMoreLink, _super);\n  function TimeColMoreLink() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.rootElRef = createRef();\n    return _this;\n  }\n  TimeColMoreLink.prototype.render = function () {\n    var _this = this;\n    var props = this.props;\n    return createElement(MoreLinkRoot, {\n      allDayDate: null,\n      moreCnt: props.hiddenSegs.length,\n      allSegs: props.hiddenSegs,\n      hiddenSegs: props.hiddenSegs,\n      alignmentElRef: this.rootElRef,\n      defaultContent: renderMoreLinkInner,\n      extraDateSpan: props.extraDateSpan,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      popoverContent: function () {\n        return renderPlainFgSegs(props.hiddenSegs, props);\n      }\n    }, function (rootElRef, classNames, innerElRef, innerContent, handleClick, title, isExpanded, popoverId) {\n      return createElement(\"a\", {\n        ref: function (el) {\n          setRef(rootElRef, el);\n          setRef(_this.rootElRef, el);\n        },\n        className: ['fc-timegrid-more-link'].concat(classNames).join(' '),\n        style: {\n          top: props.top,\n          bottom: props.bottom\n        },\n        onClick: handleClick,\n        title: title,\n        \"aria-expanded\": isExpanded,\n        \"aria-controls\": popoverId\n      }, createElement(\"div\", {\n        ref: innerElRef,\n        className: \"fc-timegrid-more-link-inner fc-sticky\"\n      }, innerContent));\n    });\n  };\n  return TimeColMoreLink;\n}(BaseComponent);\nfunction renderMoreLinkInner(props) {\n  return props.shortText;\n}\n\n// segInputs assumed sorted\nfunction buildPositioning(segInputs, strictOrder, maxStackCnt) {\n  var hierarchy = new SegHierarchy();\n  if (strictOrder != null) {\n    hierarchy.strictOrder = strictOrder;\n  }\n  if (maxStackCnt != null) {\n    hierarchy.maxStackCnt = maxStackCnt;\n  }\n  var hiddenEntries = hierarchy.addSegs(segInputs);\n  var hiddenGroups = groupIntersectingEntries(hiddenEntries);\n  var web = buildWeb(hierarchy);\n  web = stretchWeb(web, 1); // all levelCoords/thickness will have 0.0-1.0\n  var segRects = webToRects(web);\n  return {\n    segRects: segRects,\n    hiddenGroups: hiddenGroups\n  };\n}\nfunction buildWeb(hierarchy) {\n  var entriesByLevel = hierarchy.entriesByLevel;\n  var buildNode = cacheable(function (level, lateral) {\n    return level + ':' + lateral;\n  }, function (level, lateral) {\n    var siblingRange = findNextLevelSegs(hierarchy, level, lateral);\n    var nextLevelRes = buildNodes(siblingRange, buildNode);\n    var entry = entriesByLevel[level][lateral];\n    return [__assign(__assign({}, entry), {\n      nextLevelNodes: nextLevelRes[0]\n    }), entry.thickness + nextLevelRes[1] // the pressure builds\n    ];\n  });\n  return buildNodes(entriesByLevel.length ? {\n    level: 0,\n    lateralStart: 0,\n    lateralEnd: entriesByLevel[0].length\n  } : null, buildNode)[0];\n}\nfunction buildNodes(siblingRange, buildNode) {\n  if (!siblingRange) {\n    return [[], 0];\n  }\n  var level = siblingRange.level,\n    lateralStart = siblingRange.lateralStart,\n    lateralEnd = siblingRange.lateralEnd;\n  var lateral = lateralStart;\n  var pairs = [];\n  while (lateral < lateralEnd) {\n    pairs.push(buildNode(level, lateral));\n    lateral += 1;\n  }\n  pairs.sort(cmpDescPressures);\n  return [pairs.map(extractNode), pairs[0][1] // first item's pressure\n  ];\n}\nfunction cmpDescPressures(a, b) {\n  return b[1] - a[1];\n}\nfunction extractNode(a) {\n  return a[0];\n}\nfunction findNextLevelSegs(hierarchy, subjectLevel, subjectLateral) {\n  var levelCoords = hierarchy.levelCoords,\n    entriesByLevel = hierarchy.entriesByLevel;\n  var subjectEntry = entriesByLevel[subjectLevel][subjectLateral];\n  var afterSubject = levelCoords[subjectLevel] + subjectEntry.thickness;\n  var levelCnt = levelCoords.length;\n  var level = subjectLevel;\n  // skip past levels that are too high up\n  for (; level < levelCnt && levelCoords[level] < afterSubject; level += 1); // do nothing\n  for (; level < levelCnt; level += 1) {\n    var entries = entriesByLevel[level];\n    var entry = void 0;\n    var searchIndex = binarySearch(entries, subjectEntry.span.start, getEntrySpanEnd);\n    var lateralStart = searchIndex[0] + searchIndex[1]; // if exact match (which doesn't collide), go to next one\n    var lateralEnd = lateralStart;\n    while (\n    // loop through entries that horizontally intersect\n    (entry = entries[lateralEnd]) &&\n    // but not past the whole seg list\n    entry.span.start < subjectEntry.span.end) {\n      lateralEnd += 1;\n    }\n    if (lateralStart < lateralEnd) {\n      return {\n        level: level,\n        lateralStart: lateralStart,\n        lateralEnd: lateralEnd\n      };\n    }\n  }\n  return null;\n}\nfunction stretchWeb(topLevelNodes, totalThickness) {\n  var stretchNode = cacheable(function (node, startCoord, prevThickness) {\n    return buildEntryKey(node);\n  }, function (node, startCoord, prevThickness) {\n    var nextLevelNodes = node.nextLevelNodes,\n      thickness = node.thickness;\n    var allThickness = thickness + prevThickness;\n    var thicknessFraction = thickness / allThickness;\n    var endCoord;\n    var newChildren = [];\n    if (!nextLevelNodes.length) {\n      endCoord = totalThickness;\n    } else {\n      for (var _i = 0, nextLevelNodes_1 = nextLevelNodes; _i < nextLevelNodes_1.length; _i++) {\n        var childNode = nextLevelNodes_1[_i];\n        if (endCoord === undefined) {\n          var res = stretchNode(childNode, startCoord, allThickness);\n          endCoord = res[0];\n          newChildren.push(res[1]);\n        } else {\n          var res = stretchNode(childNode, endCoord, 0);\n          newChildren.push(res[1]);\n        }\n      }\n    }\n    var newThickness = (endCoord - startCoord) * thicknessFraction;\n    return [endCoord - newThickness, __assign(__assign({}, node), {\n      thickness: newThickness,\n      nextLevelNodes: newChildren\n    })];\n  });\n  return topLevelNodes.map(function (node) {\n    return stretchNode(node, 0, 0)[1];\n  });\n}\n// not sorted in any particular order\nfunction webToRects(topLevelNodes) {\n  var rects = [];\n  var processNode = cacheable(function (node, levelCoord, stackDepth) {\n    return buildEntryKey(node);\n  }, function (node, levelCoord, stackDepth) {\n    var rect = __assign(__assign({}, node), {\n      levelCoord: levelCoord,\n      stackDepth: stackDepth,\n      stackForward: 0\n    });\n    rects.push(rect);\n    return rect.stackForward = processNodes(node.nextLevelNodes, levelCoord + node.thickness, stackDepth + 1) + 1;\n  });\n  function processNodes(nodes, levelCoord, stackDepth) {\n    var stackForward = 0;\n    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n      var node = nodes_1[_i];\n      stackForward = Math.max(processNode(node, levelCoord, stackDepth), stackForward);\n    }\n    return stackForward;\n  }\n  processNodes(topLevelNodes, 0, 0);\n  return rects; // TODO: sort rects by levelCoord to be consistent with toRects?\n}\n// TODO: move to general util\nfunction cacheable(keyFunc, workFunc) {\n  var cache = {};\n  return function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var key = keyFunc.apply(void 0, args);\n    return key in cache ? cache[key] : cache[key] = workFunc.apply(void 0, args);\n  };\n}\nfunction computeSegVCoords(segs, colDate, slatCoords, eventMinHeight) {\n  if (slatCoords === void 0) {\n    slatCoords = null;\n  }\n  if (eventMinHeight === void 0) {\n    eventMinHeight = 0;\n  }\n  var vcoords = [];\n  if (slatCoords) {\n    for (var i = 0; i < segs.length; i += 1) {\n      var seg = segs[i];\n      var spanStart = slatCoords.computeDateTop(seg.start, colDate);\n      var spanEnd = Math.max(spanStart + (eventMinHeight || 0),\n      // :(\n      slatCoords.computeDateTop(seg.end, colDate));\n      vcoords.push({\n        start: Math.round(spanStart),\n        end: Math.round(spanEnd) //\n      });\n    }\n  }\n  return vcoords;\n}\nfunction computeFgSegPlacements(segs, segVCoords,\n// might not have for every seg\neventOrderStrict, eventMaxStack) {\n  var segInputs = [];\n  var dumbSegs = []; // segs without coords\n  for (var i = 0; i < segs.length; i += 1) {\n    var vcoords = segVCoords[i];\n    if (vcoords) {\n      segInputs.push({\n        index: i,\n        thickness: 1,\n        span: vcoords\n      });\n    } else {\n      dumbSegs.push(segs[i]);\n    }\n  }\n  var _a = buildPositioning(segInputs, eventOrderStrict, eventMaxStack),\n    segRects = _a.segRects,\n    hiddenGroups = _a.hiddenGroups;\n  var segPlacements = [];\n  for (var _i = 0, segRects_1 = segRects; _i < segRects_1.length; _i++) {\n    var segRect = segRects_1[_i];\n    segPlacements.push({\n      seg: segs[segRect.index],\n      rect: segRect\n    });\n  }\n  for (var _b = 0, dumbSegs_1 = dumbSegs; _b < dumbSegs_1.length; _b++) {\n    var dumbSeg = dumbSegs_1[_b];\n    segPlacements.push({\n      seg: dumbSeg,\n      rect: null\n    });\n  }\n  return {\n    segPlacements: segPlacements,\n    hiddenGroups: hiddenGroups\n  };\n}\nvar DEFAULT_TIME_FORMAT = createFormatter({\n  hour: 'numeric',\n  minute: '2-digit',\n  meridiem: false\n});\nvar TimeColEvent = /** @class */function (_super) {\n  __extends(TimeColEvent, _super);\n  function TimeColEvent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  TimeColEvent.prototype.render = function () {\n    var classNames = ['fc-timegrid-event', 'fc-v-event'];\n    if (this.props.isShort) {\n      classNames.push('fc-timegrid-event-short');\n    }\n    return createElement(StandardEvent, __assign({}, this.props, {\n      defaultTimeFormat: DEFAULT_TIME_FORMAT,\n      extraClassNames: classNames\n    }));\n  };\n  return TimeColEvent;\n}(BaseComponent);\nvar TimeColMisc = /** @class */function (_super) {\n  __extends(TimeColMisc, _super);\n  function TimeColMisc() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  TimeColMisc.prototype.render = function () {\n    var props = this.props;\n    return createElement(DayCellContent, {\n      date: props.date,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      extraHookProps: props.extraHookProps\n    }, function (innerElRef, innerContent) {\n      return innerContent && createElement(\"div\", {\n        className: \"fc-timegrid-col-misc\",\n        ref: innerElRef\n      }, innerContent);\n    });\n  };\n  return TimeColMisc;\n}(BaseComponent);\nvar TimeCol = /** @class */function (_super) {\n  __extends(TimeCol, _super);\n  function TimeCol() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.sortEventSegs = memoize(sortEventSegs);\n    return _this;\n  }\n  // TODO: memoize event-placement?\n  TimeCol.prototype.render = function () {\n    var _this = this;\n    var _a = this,\n      props = _a.props,\n      context = _a.context;\n    var isSelectMirror = context.options.selectMirror;\n    var mirrorSegs = props.eventDrag && props.eventDrag.segs || props.eventResize && props.eventResize.segs || isSelectMirror && props.dateSelectionSegs || [];\n    var interactionAffectedInstances =\n    // TODO: messy way to compute this\n    props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};\n    var sortedFgSegs = this.sortEventSegs(props.fgEventSegs, context.options.eventOrder);\n    return createElement(DayCellRoot, {\n      elRef: props.elRef,\n      date: props.date,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      extraHookProps: props.extraHookProps\n    }, function (rootElRef, classNames, dataAttrs) {\n      return createElement(\"td\", __assign({\n        ref: rootElRef,\n        role: \"gridcell\",\n        className: ['fc-timegrid-col'].concat(classNames, props.extraClassNames || []).join(' ')\n      }, dataAttrs, props.extraDataAttrs), createElement(\"div\", {\n        className: \"fc-timegrid-col-frame\"\n      }, createElement(\"div\", {\n        className: \"fc-timegrid-col-bg\"\n      }, _this.renderFillSegs(props.businessHourSegs, 'non-business'), _this.renderFillSegs(props.bgEventSegs, 'bg-event'), _this.renderFillSegs(props.dateSelectionSegs, 'highlight')), createElement(\"div\", {\n        className: \"fc-timegrid-col-events\"\n      }, _this.renderFgSegs(sortedFgSegs, interactionAffectedInstances, false, false, false)), createElement(\"div\", {\n        className: \"fc-timegrid-col-events\"\n      }, _this.renderFgSegs(mirrorSegs, {}, Boolean(props.eventDrag), Boolean(props.eventResize), Boolean(isSelectMirror))), createElement(\"div\", {\n        className: \"fc-timegrid-now-indicator-container\"\n      }, _this.renderNowIndicator(props.nowIndicatorSegs)), createElement(TimeColMisc, {\n        date: props.date,\n        dateProfile: props.dateProfile,\n        todayRange: props.todayRange,\n        extraHookProps: props.extraHookProps\n      })));\n    });\n  };\n  TimeCol.prototype.renderFgSegs = function (sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting) {\n    var props = this.props;\n    if (props.forPrint) {\n      return renderPlainFgSegs(sortedFgSegs, props);\n    }\n    return this.renderPositionedFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting);\n  };\n  TimeCol.prototype.renderPositionedFgSegs = function (segs,\n  // if not mirror, needs to be sorted\n  segIsInvisible, isDragging, isResizing, isDateSelecting) {\n    var _this = this;\n    var _a = this.context.options,\n      eventMaxStack = _a.eventMaxStack,\n      eventShortHeight = _a.eventShortHeight,\n      eventOrderStrict = _a.eventOrderStrict,\n      eventMinHeight = _a.eventMinHeight;\n    var _b = this.props,\n      date = _b.date,\n      slatCoords = _b.slatCoords,\n      eventSelection = _b.eventSelection,\n      todayRange = _b.todayRange,\n      nowDate = _b.nowDate;\n    var isMirror = isDragging || isResizing || isDateSelecting;\n    var segVCoords = computeSegVCoords(segs, date, slatCoords, eventMinHeight);\n    var _c = computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack),\n      segPlacements = _c.segPlacements,\n      hiddenGroups = _c.hiddenGroups;\n    return createElement(Fragment, null, this.renderHiddenGroups(hiddenGroups, segs), segPlacements.map(function (segPlacement) {\n      var seg = segPlacement.seg,\n        rect = segPlacement.rect;\n      var instanceId = seg.eventRange.instance.instanceId;\n      var isVisible = isMirror || Boolean(!segIsInvisible[instanceId] && rect);\n      var vStyle = computeSegVStyle(rect && rect.span);\n      var hStyle = !isMirror && rect ? _this.computeSegHStyle(rect) : {\n        left: 0,\n        right: 0\n      };\n      var isInset = Boolean(rect) && rect.stackForward > 0;\n      var isShort = Boolean(rect) && rect.span.end - rect.span.start < eventShortHeight; // look at other places for this problem\n      return createElement(\"div\", {\n        className: 'fc-timegrid-event-harness' + (isInset ? ' fc-timegrid-event-harness-inset' : ''),\n        key: instanceId,\n        style: __assign(__assign({\n          visibility: isVisible ? '' : 'hidden'\n        }, vStyle), hStyle)\n      }, createElement(TimeColEvent, __assign({\n        seg: seg,\n        isDragging: isDragging,\n        isResizing: isResizing,\n        isDateSelecting: isDateSelecting,\n        isSelected: instanceId === eventSelection,\n        isShort: isShort\n      }, getSegMeta(seg, todayRange, nowDate))));\n    }));\n  };\n  // will already have eventMinHeight applied because segInputs already had it\n  TimeCol.prototype.renderHiddenGroups = function (hiddenGroups, segs) {\n    var _a = this.props,\n      extraDateSpan = _a.extraDateSpan,\n      dateProfile = _a.dateProfile,\n      todayRange = _a.todayRange,\n      nowDate = _a.nowDate,\n      eventSelection = _a.eventSelection,\n      eventDrag = _a.eventDrag,\n      eventResize = _a.eventResize;\n    return createElement(Fragment, null, hiddenGroups.map(function (hiddenGroup) {\n      var positionCss = computeSegVStyle(hiddenGroup.span);\n      var hiddenSegs = compileSegsFromEntries(hiddenGroup.entries, segs);\n      return createElement(TimeColMoreLink, {\n        key: buildIsoString(computeEarliestSegStart(hiddenSegs)),\n        hiddenSegs: hiddenSegs,\n        top: positionCss.top,\n        bottom: positionCss.bottom,\n        extraDateSpan: extraDateSpan,\n        dateProfile: dateProfile,\n        todayRange: todayRange,\n        nowDate: nowDate,\n        eventSelection: eventSelection,\n        eventDrag: eventDrag,\n        eventResize: eventResize\n      });\n    }));\n  };\n  TimeCol.prototype.renderFillSegs = function (segs, fillType) {\n    var _a = this,\n      props = _a.props,\n      context = _a.context;\n    var segVCoords = computeSegVCoords(segs, props.date, props.slatCoords, context.options.eventMinHeight); // don't assume all populated\n    var children = segVCoords.map(function (vcoords, i) {\n      var seg = segs[i];\n      return createElement(\"div\", {\n        key: buildEventRangeKey(seg.eventRange),\n        className: \"fc-timegrid-bg-harness\",\n        style: computeSegVStyle(vcoords)\n      }, fillType === 'bg-event' ? createElement(BgEvent, __assign({\n        seg: seg\n      }, getSegMeta(seg, props.todayRange, props.nowDate))) : renderFill(fillType));\n    });\n    return createElement(Fragment, null, children);\n  };\n  TimeCol.prototype.renderNowIndicator = function (segs) {\n    var _a = this.props,\n      slatCoords = _a.slatCoords,\n      date = _a.date;\n    if (!slatCoords) {\n      return null;\n    }\n    return segs.map(function (seg, i) {\n      return createElement(NowIndicatorRoot, {\n        isAxis: false,\n        date: date,\n        // key doesn't matter. will only ever be one\n        key: i\n      }, function (rootElRef, classNames, innerElRef, innerContent) {\n        return createElement(\"div\", {\n          ref: rootElRef,\n          className: ['fc-timegrid-now-indicator-line'].concat(classNames).join(' '),\n          style: {\n            top: slatCoords.computeDateTop(seg.start, date)\n          }\n        }, innerContent);\n      });\n    });\n  };\n  TimeCol.prototype.computeSegHStyle = function (segHCoords) {\n    var _a = this.context,\n      isRtl = _a.isRtl,\n      options = _a.options;\n    var shouldOverlap = options.slotEventOverlap;\n    var nearCoord = segHCoords.levelCoord; // the left side if LTR. the right side if RTL. floating-point\n    var farCoord = segHCoords.levelCoord + segHCoords.thickness; // the right side if LTR. the left side if RTL. floating-point\n    var left; // amount of space from left edge, a fraction of the total width\n    var right; // amount of space from right edge, a fraction of the total width\n    if (shouldOverlap) {\n      // double the width, but don't go beyond the maximum forward coordinate (1.0)\n      farCoord = Math.min(1, nearCoord + (farCoord - nearCoord) * 2);\n    }\n    if (isRtl) {\n      left = 1 - farCoord;\n      right = nearCoord;\n    } else {\n      left = nearCoord;\n      right = 1 - farCoord;\n    }\n    var props = {\n      zIndex: segHCoords.stackDepth + 1,\n      left: left * 100 + '%',\n      right: right * 100 + '%'\n    };\n    if (shouldOverlap && !segHCoords.stackForward) {\n      // add padding to the edge so that forward stacked events don't cover the resizer's icon\n      props[isRtl ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width\n    }\n    return props;\n  };\n  return TimeCol;\n}(BaseComponent);\nfunction renderPlainFgSegs(sortedFgSegs, _a) {\n  var todayRange = _a.todayRange,\n    nowDate = _a.nowDate,\n    eventSelection = _a.eventSelection,\n    eventDrag = _a.eventDrag,\n    eventResize = _a.eventResize;\n  var hiddenInstances = (eventDrag ? eventDrag.affectedInstances : null) || (eventResize ? eventResize.affectedInstances : null) || {};\n  return createElement(Fragment, null, sortedFgSegs.map(function (seg) {\n    var instanceId = seg.eventRange.instance.instanceId;\n    return createElement(\"div\", {\n      key: instanceId,\n      style: {\n        visibility: hiddenInstances[instanceId] ? 'hidden' : ''\n      }\n    }, createElement(TimeColEvent, __assign({\n      seg: seg,\n      isDragging: false,\n      isResizing: false,\n      isDateSelecting: false,\n      isSelected: instanceId === eventSelection,\n      isShort: false\n    }, getSegMeta(seg, todayRange, nowDate))));\n  }));\n}\nfunction computeSegVStyle(segVCoords) {\n  if (!segVCoords) {\n    return {\n      top: '',\n      bottom: ''\n    };\n  }\n  return {\n    top: segVCoords.start,\n    bottom: -segVCoords.end\n  };\n}\nfunction compileSegsFromEntries(segEntries, allSegs) {\n  return segEntries.map(function (segEntry) {\n    return allSegs[segEntry.index];\n  });\n}\nvar TimeColsContent = /** @class */function (_super) {\n  __extends(TimeColsContent, _super);\n  function TimeColsContent() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.splitFgEventSegs = memoize(splitSegsByCol);\n    _this.splitBgEventSegs = memoize(splitSegsByCol);\n    _this.splitBusinessHourSegs = memoize(splitSegsByCol);\n    _this.splitNowIndicatorSegs = memoize(splitSegsByCol);\n    _this.splitDateSelectionSegs = memoize(splitSegsByCol);\n    _this.splitEventDrag = memoize(splitInteractionByCol);\n    _this.splitEventResize = memoize(splitInteractionByCol);\n    _this.rootElRef = createRef();\n    _this.cellElRefs = new RefMap();\n    return _this;\n  }\n  TimeColsContent.prototype.render = function () {\n    var _this = this;\n    var _a = this,\n      props = _a.props,\n      context = _a.context;\n    var nowIndicatorTop = context.options.nowIndicator && props.slatCoords && props.slatCoords.safeComputeTop(props.nowDate); // might return void\n    var colCnt = props.cells.length;\n    var fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, colCnt);\n    var bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, colCnt);\n    var businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, colCnt);\n    var nowIndicatorSegsByRow = this.splitNowIndicatorSegs(props.nowIndicatorSegs, colCnt);\n    var dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, colCnt);\n    var eventDragByRow = this.splitEventDrag(props.eventDrag, colCnt);\n    var eventResizeByRow = this.splitEventResize(props.eventResize, colCnt);\n    return createElement(\"div\", {\n      className: \"fc-timegrid-cols\",\n      ref: this.rootElRef\n    }, createElement(\"table\", {\n      role: \"presentation\",\n      style: {\n        minWidth: props.tableMinWidth,\n        width: props.clientWidth\n      }\n    }, props.tableColGroupNode, createElement(\"tbody\", {\n      role: \"presentation\"\n    }, createElement(\"tr\", {\n      role: \"row\"\n    }, props.axis && createElement(\"td\", {\n      \"aria-hidden\": true,\n      className: \"fc-timegrid-col fc-timegrid-axis\"\n    }, createElement(\"div\", {\n      className: \"fc-timegrid-col-frame\"\n    }, createElement(\"div\", {\n      className: \"fc-timegrid-now-indicator-container\"\n    }, typeof nowIndicatorTop === 'number' && createElement(NowIndicatorRoot, {\n      isAxis: true,\n      date: props.nowDate\n    }, function (rootElRef, classNames, innerElRef, innerContent) {\n      return createElement(\"div\", {\n        ref: rootElRef,\n        className: ['fc-timegrid-now-indicator-arrow'].concat(classNames).join(' '),\n        style: {\n          top: nowIndicatorTop\n        }\n      }, innerContent);\n    })))), props.cells.map(function (cell, i) {\n      return createElement(TimeCol, {\n        key: cell.key,\n        elRef: _this.cellElRefs.createRef(cell.key),\n        dateProfile: props.dateProfile,\n        date: cell.date,\n        nowDate: props.nowDate,\n        todayRange: props.todayRange,\n        extraHookProps: cell.extraHookProps,\n        extraDataAttrs: cell.extraDataAttrs,\n        extraClassNames: cell.extraClassNames,\n        extraDateSpan: cell.extraDateSpan,\n        fgEventSegs: fgEventSegsByRow[i],\n        bgEventSegs: bgEventSegsByRow[i],\n        businessHourSegs: businessHourSegsByRow[i],\n        nowIndicatorSegs: nowIndicatorSegsByRow[i],\n        dateSelectionSegs: dateSelectionSegsByRow[i],\n        eventDrag: eventDragByRow[i],\n        eventResize: eventResizeByRow[i],\n        slatCoords: props.slatCoords,\n        eventSelection: props.eventSelection,\n        forPrint: props.forPrint\n      });\n    })))));\n  };\n  TimeColsContent.prototype.componentDidMount = function () {\n    this.updateCoords();\n  };\n  TimeColsContent.prototype.componentDidUpdate = function () {\n    this.updateCoords();\n  };\n  TimeColsContent.prototype.updateCoords = function () {\n    var props = this.props;\n    if (props.onColCoords && props.clientWidth !== null // means sizing has stabilized\n    ) {\n      props.onColCoords(new PositionCache(this.rootElRef.current, collectCellEls(this.cellElRefs.currentMap, props.cells), true,\n      // horizontal\n      false));\n    }\n  };\n  return TimeColsContent;\n}(BaseComponent);\nfunction collectCellEls(elMap, cells) {\n  return cells.map(function (cell) {\n    return elMap[cell.key];\n  });\n}\n\n/* A component that renders one or more columns of vertical time slots\n----------------------------------------------------------------------------------------------------------------------*/\nvar TimeCols = /** @class */function (_super) {\n  __extends(TimeCols, _super);\n  function TimeCols() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.processSlotOptions = memoize(processSlotOptions);\n    _this.state = {\n      slatCoords: null\n    };\n    _this.handleRootEl = function (el) {\n      if (el) {\n        _this.context.registerInteractiveComponent(_this, {\n          el: el,\n          isHitComboAllowed: _this.props.isHitComboAllowed\n        });\n      } else {\n        _this.context.unregisterInteractiveComponent(_this);\n      }\n    };\n    _this.handleScrollRequest = function (request) {\n      var onScrollTopRequest = _this.props.onScrollTopRequest;\n      var slatCoords = _this.state.slatCoords;\n      if (onScrollTopRequest && slatCoords) {\n        if (request.time) {\n          var top_1 = slatCoords.computeTimeTop(request.time);\n          top_1 = Math.ceil(top_1); // zoom can give weird floating-point values. rather scroll a little bit further\n          if (top_1) {\n            top_1 += 1; // to overcome top border that slots beyond the first have. looks better\n          }\n          onScrollTopRequest(top_1);\n        }\n        return true;\n      }\n      return false;\n    };\n    _this.handleColCoords = function (colCoords) {\n      _this.colCoords = colCoords;\n    };\n    _this.handleSlatCoords = function (slatCoords) {\n      _this.setState({\n        slatCoords: slatCoords\n      });\n      if (_this.props.onSlatCoords) {\n        _this.props.onSlatCoords(slatCoords);\n      }\n    };\n    return _this;\n  }\n  TimeCols.prototype.render = function () {\n    var _a = this,\n      props = _a.props,\n      state = _a.state;\n    return createElement(\"div\", {\n      className: \"fc-timegrid-body\",\n      ref: this.handleRootEl,\n      style: {\n        // these props are important to give this wrapper correct dimensions for interactions\n        // TODO: if we set it here, can we avoid giving to inner tables?\n        width: props.clientWidth,\n        minWidth: props.tableMinWidth\n      }\n    }, createElement(TimeColsSlats, {\n      axis: props.axis,\n      dateProfile: props.dateProfile,\n      slatMetas: props.slatMetas,\n      clientWidth: props.clientWidth,\n      minHeight: props.expandRows ? props.clientHeight : '',\n      tableMinWidth: props.tableMinWidth,\n      tableColGroupNode: props.axis ? props.tableColGroupNode : null /* axis depends on the colgroup's shrinking */,\n      onCoords: this.handleSlatCoords\n    }), createElement(TimeColsContent, {\n      cells: props.cells,\n      axis: props.axis,\n      dateProfile: props.dateProfile,\n      businessHourSegs: props.businessHourSegs,\n      bgEventSegs: props.bgEventSegs,\n      fgEventSegs: props.fgEventSegs,\n      dateSelectionSegs: props.dateSelectionSegs,\n      eventSelection: props.eventSelection,\n      eventDrag: props.eventDrag,\n      eventResize: props.eventResize,\n      todayRange: props.todayRange,\n      nowDate: props.nowDate,\n      nowIndicatorSegs: props.nowIndicatorSegs,\n      clientWidth: props.clientWidth,\n      tableMinWidth: props.tableMinWidth,\n      tableColGroupNode: props.tableColGroupNode,\n      slatCoords: state.slatCoords,\n      onColCoords: this.handleColCoords,\n      forPrint: props.forPrint\n    }));\n  };\n  TimeCols.prototype.componentDidMount = function () {\n    this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);\n  };\n  TimeCols.prototype.componentDidUpdate = function (prevProps) {\n    this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);\n  };\n  TimeCols.prototype.componentWillUnmount = function () {\n    this.scrollResponder.detach();\n  };\n  TimeCols.prototype.queryHit = function (positionLeft, positionTop) {\n    var _a = this.context,\n      dateEnv = _a.dateEnv,\n      options = _a.options;\n    var colCoords = this.colCoords;\n    var dateProfile = this.props.dateProfile;\n    var slatCoords = this.state.slatCoords;\n    var _b = this.processSlotOptions(this.props.slotDuration, options.snapDuration),\n      snapDuration = _b.snapDuration,\n      snapsPerSlot = _b.snapsPerSlot;\n    var colIndex = colCoords.leftToIndex(positionLeft);\n    var slatIndex = slatCoords.positions.topToIndex(positionTop);\n    if (colIndex != null && slatIndex != null) {\n      var cell = this.props.cells[colIndex];\n      var slatTop = slatCoords.positions.tops[slatIndex];\n      var slatHeight = slatCoords.positions.getHeight(slatIndex);\n      var partial = (positionTop - slatTop) / slatHeight; // floating point number between 0 and 1\n      var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat\n      var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;\n      var dayDate = this.props.cells[colIndex].date;\n      var time = addDurations(dateProfile.slotMinTime, multiplyDuration(snapDuration, snapIndex));\n      var start = dateEnv.add(dayDate, time);\n      var end = dateEnv.add(start, snapDuration);\n      return {\n        dateProfile: dateProfile,\n        dateSpan: __assign({\n          range: {\n            start: start,\n            end: end\n          },\n          allDay: false\n        }, cell.extraDateSpan),\n        dayEl: colCoords.els[colIndex],\n        rect: {\n          left: colCoords.lefts[colIndex],\n          right: colCoords.rights[colIndex],\n          top: slatTop,\n          bottom: slatTop + slatHeight\n        },\n        layer: 0\n      };\n    }\n    return null;\n  };\n  return TimeCols;\n}(DateComponent);\nfunction processSlotOptions(slotDuration, snapDurationOverride) {\n  var snapDuration = snapDurationOverride || slotDuration;\n  var snapsPerSlot = wholeDivideDurations(slotDuration, snapDuration);\n  if (snapsPerSlot === null) {\n    snapDuration = slotDuration;\n    snapsPerSlot = 1;\n    // TODO: say warning?\n  }\n  return {\n    snapDuration: snapDuration,\n    snapsPerSlot: snapsPerSlot\n  };\n}\nvar DayTimeColsSlicer = /** @class */function (_super) {\n  __extends(DayTimeColsSlicer, _super);\n  function DayTimeColsSlicer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  DayTimeColsSlicer.prototype.sliceRange = function (range, dayRanges) {\n    var segs = [];\n    for (var col = 0; col < dayRanges.length; col += 1) {\n      var segRange = intersectRanges(range, dayRanges[col]);\n      if (segRange) {\n        segs.push({\n          start: segRange.start,\n          end: segRange.end,\n          isStart: segRange.start.valueOf() === range.start.valueOf(),\n          isEnd: segRange.end.valueOf() === range.end.valueOf(),\n          col: col\n        });\n      }\n    }\n    return segs;\n  };\n  return DayTimeColsSlicer;\n}(Slicer);\nvar DayTimeCols = /** @class */function (_super) {\n  __extends(DayTimeCols, _super);\n  function DayTimeCols() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.buildDayRanges = memoize(buildDayRanges);\n    _this.slicer = new DayTimeColsSlicer();\n    _this.timeColsRef = createRef();\n    return _this;\n  }\n  DayTimeCols.prototype.render = function () {\n    var _this = this;\n    var _a = this,\n      props = _a.props,\n      context = _a.context;\n    var dateProfile = props.dateProfile,\n      dayTableModel = props.dayTableModel;\n    var isNowIndicator = context.options.nowIndicator;\n    var dayRanges = this.buildDayRanges(dayTableModel, dateProfile, context.dateEnv);\n    // give it the first row of cells\n    // TODO: would move this further down hierarchy, but sliceNowDate needs it\n    return createElement(NowTimer, {\n      unit: isNowIndicator ? 'minute' : 'day'\n    }, function (nowDate, todayRange) {\n      return createElement(TimeCols, __assign({\n        ref: _this.timeColsRef\n      }, _this.slicer.sliceProps(props, dateProfile, null, context, dayRanges), {\n        forPrint: props.forPrint,\n        axis: props.axis,\n        dateProfile: dateProfile,\n        slatMetas: props.slatMetas,\n        slotDuration: props.slotDuration,\n        cells: dayTableModel.cells[0],\n        tableColGroupNode: props.tableColGroupNode,\n        tableMinWidth: props.tableMinWidth,\n        clientWidth: props.clientWidth,\n        clientHeight: props.clientHeight,\n        expandRows: props.expandRows,\n        nowDate: nowDate,\n        nowIndicatorSegs: isNowIndicator && _this.slicer.sliceNowDate(nowDate, context, dayRanges),\n        todayRange: todayRange,\n        onScrollTopRequest: props.onScrollTopRequest,\n        onSlatCoords: props.onSlatCoords\n      }));\n    });\n  };\n  return DayTimeCols;\n}(DateComponent);\nfunction buildDayRanges(dayTableModel, dateProfile, dateEnv) {\n  var ranges = [];\n  for (var _i = 0, _a = dayTableModel.headerDates; _i < _a.length; _i++) {\n    var date = _a[_i];\n    ranges.push({\n      start: dateEnv.add(date, dateProfile.slotMinTime),\n      end: dateEnv.add(date, dateProfile.slotMaxTime)\n    });\n  }\n  return ranges;\n}\n\n// potential nice values for the slot-duration and interval-duration\n// from largest to smallest\nvar STOCK_SUB_DURATIONS = [{\n  hours: 1\n}, {\n  minutes: 30\n}, {\n  minutes: 15\n}, {\n  seconds: 30\n}, {\n  seconds: 15\n}];\nfunction buildSlatMetas(slotMinTime, slotMaxTime, explicitLabelInterval, slotDuration, dateEnv) {\n  var dayStart = new Date(0);\n  var slatTime = slotMinTime;\n  var slatIterator = createDuration(0);\n  var labelInterval = explicitLabelInterval || computeLabelInterval(slotDuration);\n  var metas = [];\n  while (asRoughMs(slatTime) < asRoughMs(slotMaxTime)) {\n    var date = dateEnv.add(dayStart, slatTime);\n    var isLabeled = wholeDivideDurations(slatIterator, labelInterval) !== null;\n    metas.push({\n      date: date,\n      time: slatTime,\n      key: date.toISOString(),\n      isoTimeStr: formatIsoTimeString(date),\n      isLabeled: isLabeled\n    });\n    slatTime = addDurations(slatTime, slotDuration);\n    slatIterator = addDurations(slatIterator, slotDuration);\n  }\n  return metas;\n}\n// Computes an automatic value for slotLabelInterval\nfunction computeLabelInterval(slotDuration) {\n  var i;\n  var labelInterval;\n  var slotsPerLabel;\n  // find the smallest stock label interval that results in more than one slots-per-label\n  for (i = STOCK_SUB_DURATIONS.length - 1; i >= 0; i -= 1) {\n    labelInterval = createDuration(STOCK_SUB_DURATIONS[i]);\n    slotsPerLabel = wholeDivideDurations(labelInterval, slotDuration);\n    if (slotsPerLabel !== null && slotsPerLabel > 1) {\n      return labelInterval;\n    }\n  }\n  return slotDuration; // fall back\n}\nvar DayTimeColsView = /** @class */function (_super) {\n  __extends(DayTimeColsView, _super);\n  function DayTimeColsView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.buildTimeColsModel = memoize(buildTimeColsModel);\n    _this.buildSlatMetas = memoize(buildSlatMetas);\n    return _this;\n  }\n  DayTimeColsView.prototype.render = function () {\n    var _this = this;\n    var _a = this.context,\n      options = _a.options,\n      dateEnv = _a.dateEnv,\n      dateProfileGenerator = _a.dateProfileGenerator;\n    var props = this.props;\n    var dateProfile = props.dateProfile;\n    var dayTableModel = this.buildTimeColsModel(dateProfile, dateProfileGenerator);\n    var splitProps = this.allDaySplitter.splitProps(props);\n    var slatMetas = this.buildSlatMetas(dateProfile.slotMinTime, dateProfile.slotMaxTime, options.slotLabelInterval, options.slotDuration, dateEnv);\n    var dayMinWidth = options.dayMinWidth;\n    var hasAttachedAxis = !dayMinWidth;\n    var hasDetachedAxis = dayMinWidth;\n    var headerContent = options.dayHeaders && createElement(DayHeader, {\n      dates: dayTableModel.headerDates,\n      dateProfile: dateProfile,\n      datesRepDistinctDays: true,\n      renderIntro: hasAttachedAxis ? this.renderHeadAxis : null\n    });\n    var allDayContent = options.allDaySlot !== false && function (contentArg) {\n      return createElement(DayTable, __assign({}, splitProps.allDay, {\n        dateProfile: dateProfile,\n        dayTableModel: dayTableModel,\n        nextDayThreshold: options.nextDayThreshold,\n        tableMinWidth: contentArg.tableMinWidth,\n        colGroupNode: contentArg.tableColGroupNode,\n        renderRowIntro: hasAttachedAxis ? _this.renderTableRowAxis : null,\n        showWeekNumbers: false,\n        expandRows: false,\n        headerAlignElRef: _this.headerElRef,\n        clientWidth: contentArg.clientWidth,\n        clientHeight: contentArg.clientHeight,\n        forPrint: props.forPrint\n      }, _this.getAllDayMaxEventProps()));\n    };\n    var timeGridContent = function (contentArg) {\n      return createElement(DayTimeCols, __assign({}, splitProps.timed, {\n        dayTableModel: dayTableModel,\n        dateProfile: dateProfile,\n        axis: hasAttachedAxis,\n        slotDuration: options.slotDuration,\n        slatMetas: slatMetas,\n        forPrint: props.forPrint,\n        tableColGroupNode: contentArg.tableColGroupNode,\n        tableMinWidth: contentArg.tableMinWidth,\n        clientWidth: contentArg.clientWidth,\n        clientHeight: contentArg.clientHeight,\n        onSlatCoords: _this.handleSlatCoords,\n        expandRows: contentArg.expandRows,\n        onScrollTopRequest: _this.handleScrollTopRequest\n      }));\n    };\n    return hasDetachedAxis ? this.renderHScrollLayout(headerContent, allDayContent, timeGridContent, dayTableModel.colCnt, dayMinWidth, slatMetas, this.state.slatCoords) : this.renderSimpleLayout(headerContent, allDayContent, timeGridContent);\n  };\n  return DayTimeColsView;\n}(TimeColsView);\nfunction buildTimeColsModel(dateProfile, dateProfileGenerator) {\n  var daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);\n  return new DayTableModel(daySeries, false);\n}\nvar OPTION_REFINERS = {\n  allDaySlot: Boolean\n};\nvar main = createPlugin({\n  initialView: 'timeGridWeek',\n  optionRefiners: OPTION_REFINERS,\n  views: {\n    timeGrid: {\n      component: DayTimeColsView,\n      usesMinMaxTime: true,\n      allDaySlot: true,\n      slotDuration: '00:30:00',\n      slotEventOverlap: true // a bad name. confused with overlap/constraint system\n    },\n    timeGridDay: {\n      type: 'timeGrid',\n      duration: {\n        days: 1\n      }\n    },\n    timeGridWeek: {\n      type: 'timeGrid',\n      duration: {\n        weeks: 1\n      }\n    }\n  }\n});\nexport default main;\nexport { DayTimeCols, DayTimeColsSlicer, DayTimeColsView, TimeCols, TimeColsSlatsCoords, TimeColsView, buildDayRanges, buildSlatMetas, buildTimeColsModel };","map":{"version":3,"names":["AllDaySplitter","_super","__extends","prototype","getKeyInfo","allDay","timed","getKeysForDateSpan","dateSpan","getKeysForEventDef","eventDef","hasBgRendering","Splitter","DEFAULT_SLAT_LABEL_FORMAT","createFormatter","hour","minute","omitZeroMinute","meridiem","TimeColsAxisCell","props","classNames","isLabeled","createElement","ViewContextType","Consumer","context","className","join","isoTimeStr","dateEnv","options","viewApi","labelFormat","slotLabelFormat","Array","isArray","hookProps","level","time","date","toDate","view","text","format","RenderHook","slotLabelClassNames","content","slotLabelContent","defaultContent","renderInnerContent","didMount","slotLabelDidMount","willUnmount","slotLabelWillUnmount","rootElRef","customClassNames","innerElRef","innerContent","ref","concat","TimeBodyAxis","render","slatMetas","map","slatMeta","key","__assign","BaseComponent","DEFAULT_WEEK_NUM_FORMAT","week","AUTO_ALL_DAY_MAX_EVENT_ROWS","TimeColsView","_this","apply","arguments","allDaySplitter","headerElRef","createRef","scrollerElRef","state","slatCoords","handleScrollTopRequest","scrollTop","scrollerEl","current","renderHeadAxis","rowKey","frameHeight","dateProfile","range","renderRange","dayCnt","diffDays","start","end","navLinkAttrs","buildNavLinkAttrs","weekNumbers","WeekNumberRoot","defaultFormat","style","height","renderTableRowAxis","rowHeight","_a","allDayText","allDayClassNames","allDayContent","renderAllDayInner","allDayDidMount","allDayWillUnmount","handleSlatCoords","setState","renderSimpleLayout","headerRowContent","timeContent","sections","stickyHeaderDates","getStickyHeaderDates","push","type","isSticky","chunk","elRef","tableClassName","rowContent","outerContent","role","theme","getClass","liquid","expandRows","Boolean","ViewRoot","viewSpec","SimpleScrollGrid","isHeightAuto","forPrint","collapsibleWidth","cols","width","renderHScrollLayout","colCnt","dayMinWidth","ScrollGrid","pluginHooks","scrollGridImpl","Error","stickyFooterScrollbar","getStickyFooterScrollbar","syncRowHeights","chunks","arg","rowSyncHeights","contentArg","colSpan","isNowIndicator","nowIndicator","clientHeight","tableColGroupNode","NowTimer","unit","nowDate","nowIndicatorTop","safeComputeTop","NowIndicatorRoot","isAxis","top","renderScrollShim","colGroups","span","minWidth","getAllDayMaxEventProps","dayMaxEvents","dayMaxEventRows","undefined","DateComponent","TimeColsSlatsCoords","positions","slotDuration","rangeContainsMarker","currentRange","startOfDayDate","startOfDay","timeMs","valueOf","asRoughMs","slotMinTime","slotMaxTime","computeTimeTop","createDuration","computeDateTop","when","duration","len","els","length","slatCoverage","milliseconds","slatIndex","slatRemainder","Math","max","min","floor","tops","getHeight","TimeColsSlatsBody","slatElRefs","i","axis","slotLaneClassNames","slotLaneContent","slotLaneDidMount","slotLaneWillUnmount","TimeColsSlats","RefMap","tableMinWidth","clientWidth","minHeight","componentDidMount","updateSizing","componentDidUpdate","componentWillUnmount","onCoords","rootEl","offsetHeight","PositionCache","collectSlatEls","currentMap","elMap","splitSegsByCol","segs","segsByCol","col","splitInteractionByCol","ui","byRow","affectedInstances","isEvent","_i","seg","TimeColMoreLink","MoreLinkRoot","allDayDate","moreCnt","hiddenSegs","allSegs","alignmentElRef","renderMoreLinkInner","extraDateSpan","todayRange","popoverContent","renderPlainFgSegs","handleClick","title","isExpanded","popoverId","el","setRef","bottom","onClick","shortText","buildPositioning","segInputs","strictOrder","maxStackCnt","hierarchy","SegHierarchy","hiddenEntries","addSegs","hiddenGroups","groupIntersectingEntries","web","buildWeb","stretchWeb","segRects","webToRects","entriesByLevel","buildNode","cacheable","lateral","siblingRange","findNextLevelSegs","nextLevelRes","buildNodes","entry","nextLevelNodes","thickness","lateralStart","lateralEnd","pairs","sort","cmpDescPressures","extractNode","a","b","subjectLevel","subjectLateral","levelCoords","subjectEntry","afterSubject","levelCnt","entries","searchIndex","binarySearch","getEntrySpanEnd","topLevelNodes","totalThickness","stretchNode","node","startCoord","prevThickness","buildEntryKey","allThickness","thicknessFraction","endCoord","newChildren","nextLevelNodes_1","childNode","res","newThickness","rects","processNode","levelCoord","stackDepth","rect","stackForward","processNodes","nodes","nodes_1","keyFunc","workFunc","cache","args","computeSegVCoords","colDate","eventMinHeight","vcoords","spanStart","spanEnd","round","computeFgSegPlacements","segVCoords","eventOrderStrict","eventMaxStack","dumbSegs","index","segPlacements","segRects_1","segRect","_b","dumbSegs_1","dumbSeg","DEFAULT_TIME_FORMAT","TimeColEvent","isShort","StandardEvent","defaultTimeFormat","extraClassNames","TimeColMisc","DayCellContent","extraHookProps","TimeCol","sortEventSegs","memoize","isSelectMirror","selectMirror","mirrorSegs","eventDrag","eventResize","dateSelectionSegs","interactionAffectedInstances","sortedFgSegs","fgEventSegs","eventOrder","DayCellRoot","dataAttrs","extraDataAttrs","renderFillSegs","businessHourSegs","bgEventSegs","renderFgSegs","renderNowIndicator","nowIndicatorSegs","segIsInvisible","isDragging","isResizing","isDateSelecting","renderPositionedFgSegs","eventShortHeight","eventSelection","isMirror","_c","Fragment","renderHiddenGroups","segPlacement","instanceId","eventRange","instance","isVisible","vStyle","computeSegVStyle","hStyle","computeSegHStyle","left","right","isInset","visibility","isSelected","getSegMeta","hiddenGroup","positionCss","compileSegsFromEntries","buildIsoString","computeEarliestSegStart","fillType","children","buildEventRangeKey","BgEvent","renderFill","segHCoords","isRtl","shouldOverlap","slotEventOverlap","nearCoord","farCoord","zIndex","hiddenInstances","segEntries","segEntry","TimeColsContent","splitFgEventSegs","splitBgEventSegs","splitBusinessHourSegs","splitNowIndicatorSegs","splitDateSelectionSegs","splitEventDrag","splitEventResize","cellElRefs","cells","fgEventSegsByRow","bgEventSegsByRow","businessHourSegsByRow","nowIndicatorSegsByRow","dateSelectionSegsByRow","eventDragByRow","eventResizeByRow","cell","updateCoords","onColCoords","collectCellEls","TimeCols","processSlotOptions","handleRootEl","registerInteractiveComponent","isHitComboAllowed","unregisterInteractiveComponent","handleScrollRequest","request","onScrollTopRequest","top_1","ceil","handleColCoords","colCoords","onSlatCoords","scrollResponder","createScrollResponder","prevProps","update","detach","queryHit","positionLeft","positionTop","snapDuration","snapsPerSlot","colIndex","leftToIndex","topToIndex","slatTop","slatHeight","partial","localSnapIndex","snapIndex","dayDate","addDurations","multiplyDuration","add","dayEl","lefts","rights","layer","snapDurationOverride","wholeDivideDurations","DayTimeColsSlicer","sliceRange","dayRanges","segRange","intersectRanges","isStart","isEnd","Slicer","DayTimeCols","buildDayRanges","slicer","timeColsRef","dayTableModel","sliceProps","sliceNowDate","ranges","headerDates","STOCK_SUB_DURATIONS","hours","minutes","seconds","buildSlatMetas","explicitLabelInterval","dayStart","Date","slatTime","slatIterator","labelInterval","computeLabelInterval","metas","toISOString","formatIsoTimeString","slotsPerLabel","DayTimeColsView","buildTimeColsModel","dateProfileGenerator","splitProps","slotLabelInterval","hasAttachedAxis","hasDetachedAxis","headerContent","dayHeaders","DayHeader","dates","datesRepDistinctDays","renderIntro","allDaySlot","DayTable","nextDayThreshold","colGroupNode","renderRowIntro","showWeekNumbers","headerAlignElRef","timeGridContent","daySeries","DaySeriesModel","DayTableModel","OPTION_REFINERS","main","createPlugin","initialView","optionRefiners","views","timeGrid","component","usesMinMaxTime","timeGridDay","days","timeGridWeek","weeks"],"sources":["C:\\Users\\MO ZAID\\OneDrive\\Desktop\\Assignment\\Calender\\client\\node_modules\\@fullcalendar\\timegrid\\src\\AllDaySplitter.ts","C:\\Users\\MO ZAID\\OneDrive\\Desktop\\Assignment\\Calender\\client\\node_modules\\@fullcalendar\\timegrid\\src\\TimeColsAxisCell.tsx","C:\\Users\\MO ZAID\\OneDrive\\Desktop\\Assignment\\Calender\\client\\node_modules\\@fullcalendar\\timegrid\\src\\TimeBodyAxis.tsx","C:\\Users\\MO ZAID\\OneDrive\\Desktop\\Assignment\\Calender\\client\\node_modules\\@fullcalendar\\timegrid\\src\\TimeColsView.tsx","C:\\Users\\MO ZAID\\OneDrive\\Desktop\\Assignment\\Calender\\client\\node_modules\\@fullcalendar\\timegrid\\src\\TimeColsSlatsCoords.ts","C:\\Users\\MO ZAID\\OneDrive\\Desktop\\Assignment\\Calender\\client\\node_modules\\@fullcalendar\\timegrid\\src\\TimeColsSlatsBody.tsx","C:\\Users\\MO ZAID\\OneDrive\\Desktop\\Assignment\\Calender\\client\\node_modules\\@fullcalendar\\timegrid\\src\\TimeColsSlats.tsx","C:\\Users\\MO ZAID\\OneDrive\\Desktop\\Assignment\\Calender\\client\\node_modules\\@fullcalendar\\timegrid\\src\\TimeColsSeg.ts","C:\\Users\\MO ZAID\\OneDrive\\Desktop\\Assignment\\Calender\\client\\node_modules\\@fullcalendar\\timegrid\\src\\TimeColMoreLink.tsx","C:\\Users\\MO ZAID\\OneDrive\\Desktop\\Assignment\\Calender\\client\\node_modules\\@fullcalendar\\timegrid\\src\\seg-web.ts","C:\\Users\\MO ZAID\\OneDrive\\Desktop\\Assignment\\Calender\\client\\node_modules\\@fullcalendar\\timegrid\\src\\event-placement.ts","C:\\Users\\MO ZAID\\OneDrive\\Desktop\\Assignment\\Calender\\client\\node_modules\\@fullcalendar\\timegrid\\src\\TimeColEvent.tsx","C:\\Users\\MO ZAID\\OneDrive\\Desktop\\Assignment\\Calender\\client\\node_modules\\@fullcalendar\\timegrid\\src\\TimeColMisc.tsx","C:\\Users\\MO ZAID\\OneDrive\\Desktop\\Assignment\\Calender\\client\\node_modules\\@fullcalendar\\timegrid\\src\\TimeCol.tsx","C:\\Users\\MO ZAID\\OneDrive\\Desktop\\Assignment\\Calender\\client\\node_modules\\@fullcalendar\\timegrid\\src\\TimeColsContent.tsx","C:\\Users\\MO ZAID\\OneDrive\\Desktop\\Assignment\\Calender\\client\\node_modules\\@fullcalendar\\timegrid\\src\\TimeCols.tsx","C:\\Users\\MO ZAID\\OneDrive\\Desktop\\Assignment\\Calender\\client\\node_modules\\@fullcalendar\\timegrid\\src\\DayTimeColsSlicer.ts","C:\\Users\\MO ZAID\\OneDrive\\Desktop\\Assignment\\Calender\\client\\node_modules\\@fullcalendar\\timegrid\\src\\DayTimeCols.tsx","C:\\Users\\MO ZAID\\OneDrive\\Desktop\\Assignment\\Calender\\client\\node_modules\\@fullcalendar\\timegrid\\src\\time-slat-meta.ts","C:\\Users\\MO ZAID\\OneDrive\\Desktop\\Assignment\\Calender\\client\\node_modules\\@fullcalendar\\timegrid\\src\\DayTimeColsView.tsx","C:\\Users\\MO ZAID\\OneDrive\\Desktop\\Assignment\\Calender\\client\\node_modules\\@fullcalendar\\timegrid\\src\\options.ts","C:\\Users\\MO ZAID\\OneDrive\\Desktop\\Assignment\\Calender\\client\\node_modules\\@fullcalendar\\timegrid\\src\\main.ts"],"sourcesContent":["import {\n  Splitter,\n  hasBgRendering,\n  EventDef,\n  DateSpan,\n} from '@fullcalendar/common'\n\nexport class AllDaySplitter extends Splitter {\n  getKeyInfo() {\n    return {\n      allDay: {},\n      timed: {},\n    }\n  }\n\n  getKeysForDateSpan(dateSpan: DateSpan): string[] {\n    if (dateSpan.allDay) {\n      return ['allDay']\n    }\n\n    return ['timed']\n  }\n\n  getKeysForEventDef(eventDef: EventDef): string[] {\n    if (!eventDef.allDay) {\n      return ['timed']\n    }\n\n    if (hasBgRendering(eventDef)) {\n      return ['timed', 'allDay']\n    }\n\n    return ['allDay']\n  }\n}\n","import {\n  createElement,\n  ViewContext,\n  createFormatter,\n  ViewContextType,\n  RenderHook,\n  SlotLabelContentArg,\n} from '@fullcalendar/common'\nimport { TimeSlatMeta } from './time-slat-meta'\n\nconst DEFAULT_SLAT_LABEL_FORMAT = createFormatter({\n  hour: 'numeric',\n  minute: '2-digit',\n  omitZeroMinute: true,\n  meridiem: 'short',\n})\n\nexport function TimeColsAxisCell(props: TimeSlatMeta) {\n  let classNames = [\n    'fc-timegrid-slot',\n    'fc-timegrid-slot-label',\n    props.isLabeled ? 'fc-scrollgrid-shrink' : 'fc-timegrid-slot-minor',\n  ]\n\n  return (\n    <ViewContextType.Consumer>\n      {(context: ViewContext) => {\n        if (!props.isLabeled) {\n          return (\n            <td className={classNames.join(' ')} data-time={props.isoTimeStr} />\n          )\n        }\n\n        let { dateEnv, options, viewApi } = context\n        let labelFormat = // TODO: fully pre-parse\n          options.slotLabelFormat == null ? DEFAULT_SLAT_LABEL_FORMAT :\n            Array.isArray(options.slotLabelFormat) ? createFormatter(options.slotLabelFormat[0]) :\n              createFormatter(options.slotLabelFormat)\n\n        let hookProps: SlotLabelContentArg = {\n          level: 0,\n          time: props.time,\n          date: dateEnv.toDate(props.date),\n          view: viewApi,\n          text: dateEnv.format(props.date, labelFormat),\n        }\n\n        return (\n          <RenderHook<SlotLabelContentArg> // needed?\n            hookProps={hookProps}\n            classNames={options.slotLabelClassNames}\n            content={options.slotLabelContent}\n            defaultContent={renderInnerContent}\n            didMount={options.slotLabelDidMount}\n            willUnmount={options.slotLabelWillUnmount}\n          >\n            {(rootElRef, customClassNames, innerElRef, innerContent) => (\n              <td ref={rootElRef} className={classNames.concat(customClassNames).join(' ')} data-time={props.isoTimeStr}>\n                <div className=\"fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame\">\n                  <div className=\"fc-timegrid-slot-label-cushion fc-scrollgrid-shrink-cushion\" ref={innerElRef}>\n                    {innerContent}\n                  </div>\n                </div>\n              </td>\n            )}\n          </RenderHook>\n        )\n      }}\n    </ViewContextType.Consumer>\n  )\n}\n\nfunction renderInnerContent(props) { // TODO: add types\n  return props.text\n}\n","import { createElement, BaseComponent } from '@fullcalendar/common'\nimport { TimeColsAxisCell } from './TimeColsAxisCell'\nimport { TimeSlatMeta } from './time-slat-meta'\n\n/* Thin Axis\n------------------------------------------------------------------------------------------------------------------*/\n\ninterface TimeBodyAxisProps {\n  slatMetas: TimeSlatMeta[]\n}\n\nexport class TimeBodyAxis extends BaseComponent<TimeBodyAxisProps> { // just <tr> content\n  render() {\n    return this.props.slatMetas.map((slatMeta: TimeSlatMeta) => (\n      <tr key={slatMeta.key}>\n        <TimeColsAxisCell {...slatMeta} />\n      </tr>\n    ))\n  }\n}\n","import {\n  createElement, createRef,\n  diffDays,\n  SimpleScrollGridSection,\n  VNode,\n  SimpleScrollGrid,\n  ChunkContentCallbackArgs,\n  ScrollGridSectionConfig,\n  buildNavLinkAttrs,\n  ViewRoot,\n  WeekNumberRoot,\n  RenderHook,\n  DateComponent,\n  ViewProps,\n  RefObject,\n  renderScrollShim,\n  getStickyHeaderDates,\n  getStickyFooterScrollbar,\n  createFormatter,\n  AllDayContentArg,\n  CssDimValue,\n  NowTimer,\n  DateMarker,\n  NowIndicatorRoot,\n} from '@fullcalendar/common'\nimport { AllDaySplitter } from './AllDaySplitter'\nimport { TimeSlatMeta } from './time-slat-meta'\nimport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\nimport { TimeBodyAxis } from './TimeBodyAxis'\n\nconst DEFAULT_WEEK_NUM_FORMAT = createFormatter({ week: 'short' })\nconst AUTO_ALL_DAY_MAX_EVENT_ROWS = 5\n\n/* An abstract class for all timegrid-related views. Displays one more columns with time slots running vertically.\n----------------------------------------------------------------------------------------------------------------------*/\n// Is a manager for the TimeCols subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).\n// Responsible for managing width/height.\n\ninterface TimeColsViewState {\n  slatCoords: TimeColsSlatsCoords | null\n}\n\nexport abstract class TimeColsView extends DateComponent<ViewProps, TimeColsViewState> {\n  protected allDaySplitter = new AllDaySplitter() // for use by subclasses\n\n  protected headerElRef: RefObject<HTMLTableCellElement> = createRef<HTMLTableCellElement>()\n  private rootElRef: RefObject<HTMLDivElement> = createRef<HTMLDivElement>()\n  private scrollerElRef: RefObject<HTMLDivElement> = createRef<HTMLDivElement>()\n\n  state = {\n    slatCoords: null,\n  }\n\n  // rendering\n  // ----------------------------------------------------------------------------------------------------\n\n  renderSimpleLayout(\n    headerRowContent: VNode | null,\n    allDayContent: ((contentArg: ChunkContentCallbackArgs) => VNode) | null,\n    timeContent: ((contentArg: ChunkContentCallbackArgs) => VNode) | null,\n  ) {\n    let { context, props } = this\n    let sections: SimpleScrollGridSection[] = []\n    let stickyHeaderDates = getStickyHeaderDates(context.options)\n\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        chunk: {\n          elRef: this.headerElRef,\n          tableClassName: 'fc-col-header',\n          rowContent: headerRowContent,\n        },\n      })\n    }\n\n    if (allDayContent) {\n      sections.push({\n        type: 'body',\n        key: 'all-day',\n        chunk: { content: allDayContent },\n      })\n      sections.push({\n        type: 'body',\n        key: 'all-day-divider',\n        outerContent: ( // TODO: rename to cellContent so don't need to define <tr>?\n          <tr role=\"presentation\" className=\"fc-scrollgrid-section\">\n            <td\n              className={'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')}\n            />\n          </tr>\n        ),\n      })\n    }\n\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      expandRows: Boolean(context.options.expandRows),\n      chunk: {\n        scrollerElRef: this.scrollerElRef,\n        content: timeContent,\n      },\n    })\n\n    return (\n      <ViewRoot viewSpec={context.viewSpec} elRef={this.rootElRef}>\n        {(rootElRef, classNames) => (\n          <div className={['fc-timegrid'].concat(classNames).join(' ')} ref={rootElRef}>\n            <SimpleScrollGrid\n              liquid={!props.isHeightAuto && !props.forPrint}\n              collapsibleWidth={props.forPrint}\n              cols={[{ width: 'shrink' }]}\n              sections={sections}\n            />\n          </div>\n        )}\n      </ViewRoot>\n    )\n  }\n\n  renderHScrollLayout(\n    headerRowContent: VNode | null,\n    allDayContent: ((contentArg: ChunkContentCallbackArgs) => VNode) | null,\n    timeContent: ((contentArg: ChunkContentCallbackArgs) => VNode) | null,\n    colCnt: number,\n    dayMinWidth: number,\n    slatMetas: TimeSlatMeta[],\n    slatCoords: TimeColsSlatsCoords | null, // yuck\n  ) {\n    let ScrollGrid = this.context.pluginHooks.scrollGridImpl\n\n    if (!ScrollGrid) {\n      throw new Error('No ScrollGrid implementation')\n    }\n\n    let { context, props } = this\n    let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options)\n    let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options)\n    let sections: ScrollGridSectionConfig[] = []\n\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        syncRowHeights: true,\n        chunks: [\n          {\n            key: 'axis',\n            rowContent: (arg: ChunkContentCallbackArgs) => (\n              <tr role=\"presentation\">\n                {this.renderHeadAxis('day', arg.rowSyncHeights[0])}\n              </tr>\n            ),\n          },\n          {\n            key: 'cols',\n            elRef: this.headerElRef,\n            tableClassName: 'fc-col-header',\n            rowContent: headerRowContent,\n          },\n        ],\n      })\n    }\n\n    if (allDayContent) {\n      sections.push({\n        type: 'body',\n        key: 'all-day',\n        syncRowHeights: true,\n        chunks: [\n          {\n            key: 'axis',\n            rowContent: (contentArg: ChunkContentCallbackArgs) => (\n              <tr role=\"presentation\">\n                {this.renderTableRowAxis(contentArg.rowSyncHeights[0])}\n              </tr>\n            ),\n          },\n          {\n            key: 'cols',\n            content: allDayContent,\n          },\n        ],\n      })\n      sections.push({\n        key: 'all-day-divider',\n        type: 'body',\n        outerContent: ( // TODO: rename to cellContent so don't need to define <tr>?\n          <tr role=\"presentation\" className=\"fc-scrollgrid-section\">\n            <td\n              colSpan={2}\n              className={'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')}\n            />\n          </tr>\n        ),\n      })\n    }\n\n    let isNowIndicator = context.options.nowIndicator\n\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      expandRows: Boolean(context.options.expandRows),\n      chunks: [\n        {\n          key: 'axis',\n          content: (arg) => (\n            // TODO: make this now-indicator arrow more DRY with TimeColsContent\n            <div className=\"fc-timegrid-axis-chunk\">\n              <table aria-hidden style={{ height: arg.expandRows ? arg.clientHeight : '' }}>\n                {arg.tableColGroupNode}\n                <tbody>\n                  <TimeBodyAxis slatMetas={slatMetas} />\n                </tbody>\n              </table>\n              <div className=\"fc-timegrid-now-indicator-container\">\n                <NowTimer unit={isNowIndicator ? 'minute' : 'day' /* hacky */}>\n                  {(nowDate: DateMarker) => {\n                    let nowIndicatorTop =\n                      isNowIndicator &&\n                      slatCoords &&\n                      slatCoords.safeComputeTop(nowDate) // might return void\n\n                    if (typeof nowIndicatorTop === 'number') {\n                      return (\n                        <NowIndicatorRoot isAxis date={nowDate}>\n                          {(rootElRef, classNames, innerElRef, innerContent) => (\n                            <div\n                              ref={rootElRef}\n                              className={['fc-timegrid-now-indicator-arrow'].concat(classNames).join(' ')}\n                              style={{ top: nowIndicatorTop }}\n                            >\n                              {innerContent}\n                            </div>\n                          )}\n                        </NowIndicatorRoot>\n                      )\n                    }\n\n                    return null\n                  }}\n                </NowTimer>\n              </div>\n            </div>\n          ),\n        },\n        {\n          key: 'cols',\n          scrollerElRef: this.scrollerElRef,\n          content: timeContent,\n        },\n      ],\n    })\n\n    if (stickyFooterScrollbar) {\n      sections.push({\n        key: 'footer',\n        type: 'footer',\n        isSticky: true,\n        chunks: [\n          {\n            key: 'axis',\n            content: renderScrollShim,\n          },\n          {\n            key: 'cols',\n            content: renderScrollShim,\n          },\n        ],\n      })\n    }\n\n    return (\n      <ViewRoot viewSpec={context.viewSpec} elRef={this.rootElRef}>\n        {(rootElRef, classNames) => (\n          <div className={['fc-timegrid'].concat(classNames).join(' ')} ref={rootElRef}>\n            <ScrollGrid\n              liquid={!props.isHeightAuto && !props.forPrint}\n              collapsibleWidth={false}\n              colGroups={[\n                { width: 'shrink', cols: [{ width: 'shrink' }] }, // TODO: allow no specify cols\n                { cols: [{ span: colCnt, minWidth: dayMinWidth }] },\n              ]}\n              sections={sections}\n            />\n          </div>\n        )}\n      </ViewRoot>\n    )\n  }\n\n  handleScrollTopRequest = (scrollTop: number) => {\n    let scrollerEl = this.scrollerElRef.current\n\n    if (scrollerEl) { // TODO: not sure how this could ever be null. weirdness with the reducer\n      scrollerEl.scrollTop = scrollTop\n    }\n  }\n\n  /* Dimensions\n  ------------------------------------------------------------------------------------------------------------------*/\n\n  getAllDayMaxEventProps() {\n    let { dayMaxEvents, dayMaxEventRows } = this.context.options\n\n    if (dayMaxEvents === true || dayMaxEventRows === true) { // is auto?\n      dayMaxEvents = undefined\n      dayMaxEventRows = AUTO_ALL_DAY_MAX_EVENT_ROWS // make sure \"auto\" goes to a real number\n    }\n\n    return { dayMaxEvents, dayMaxEventRows }\n  }\n\n  /* Header Render Methods\n  ------------------------------------------------------------------------------------------------------------------*/\n\n  renderHeadAxis = (rowKey: 'day' | string, frameHeight: CssDimValue = '') => {\n    let { options } = this.context\n    let { dateProfile } = this.props\n    let range = dateProfile.renderRange\n    let dayCnt = diffDays(range.start, range.end)\n\n    let navLinkAttrs = (dayCnt === 1) // only do in day views (to avoid doing in week views that dont need it)\n      ? buildNavLinkAttrs(this.context, range.start, 'week')\n      : {}\n\n    if (options.weekNumbers && rowKey === 'day') {\n      return (\n        <WeekNumberRoot date={range.start} defaultFormat={DEFAULT_WEEK_NUM_FORMAT}>\n          {(rootElRef, classNames, innerElRef, innerContent) => (\n            <th\n              ref={rootElRef}\n              aria-hidden\n              className={[\n                'fc-timegrid-axis',\n                'fc-scrollgrid-shrink',\n              ].concat(classNames).join(' ')}\n            >\n              <div\n                className=\"fc-timegrid-axis-frame fc-scrollgrid-shrink-frame fc-timegrid-axis-frame-liquid\"\n                style={{ height: frameHeight }}\n              >\n                <a\n                  ref={innerElRef}\n                  className=\"fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner\"\n                  {...navLinkAttrs}\n                >\n                  {innerContent}\n                </a>\n              </div>\n            </th>\n          )}\n        </WeekNumberRoot>\n      )\n    }\n\n    return (\n      <th aria-hidden className=\"fc-timegrid-axis\">\n        <div className=\"fc-timegrid-axis-frame\" style={{ height: frameHeight }} />\n      </th>\n    )\n  }\n\n  /* Table Component Render Methods\n  ------------------------------------------------------------------------------------------------------------------*/\n\n  // only a one-way height sync. we don't send the axis inner-content height to the DayGrid,\n  // but DayGrid still needs to have classNames on inner elements in order to measure.\n  renderTableRowAxis = (rowHeight?: number) => {\n    let { options, viewApi } = this.context\n    let hookProps: AllDayContentArg = {\n      text: options.allDayText,\n      view: viewApi,\n    }\n\n    return (\n      // TODO: make reusable hook. used in list view too\n      <RenderHook<AllDayContentArg>\n        hookProps={hookProps}\n        classNames={options.allDayClassNames}\n        content={options.allDayContent}\n        defaultContent={renderAllDayInner}\n        didMount={options.allDayDidMount}\n        willUnmount={options.allDayWillUnmount}\n      >\n        {(rootElRef, classNames, innerElRef, innerContent) => (\n          <td\n            ref={rootElRef}\n            aria-hidden\n            className={[\n              'fc-timegrid-axis',\n              'fc-scrollgrid-shrink',\n            ].concat(classNames).join(' ')}\n          >\n            <div\n              className={'fc-timegrid-axis-frame fc-scrollgrid-shrink-frame' + (rowHeight == null ? ' fc-timegrid-axis-frame-liquid' : '')}\n              style={{ height: rowHeight }}\n            >\n              <span className=\"fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner\" ref={innerElRef}>\n                {innerContent}\n              </span>\n            </div>\n          </td>\n        )}\n      </RenderHook>\n    )\n  }\n\n  handleSlatCoords = (slatCoords: TimeColsSlatsCoords) => {\n    this.setState({ slatCoords })\n  }\n}\n\nfunction renderAllDayInner(hookProps) {\n  return hookProps.text\n}\n","import {\n  PositionCache,\n  DateMarker,\n  startOfDay,\n  createDuration,\n  asRoughMs,\n  DateProfile,\n  Duration,\n  rangeContainsMarker,\n} from '@fullcalendar/common'\n\nexport class TimeColsSlatsCoords {\n  constructor(\n    public positions: PositionCache,\n    private dateProfile: DateProfile,\n    private slotDuration: Duration,\n  ) {\n  }\n\n  safeComputeTop(date: DateMarker) { // TODO: DRY with computeDateTop\n    let { dateProfile } = this\n\n    if (rangeContainsMarker(dateProfile.currentRange, date)) {\n      let startOfDayDate = startOfDay(date)\n      let timeMs = date.valueOf() - startOfDayDate.valueOf()\n\n      if (\n        timeMs >= asRoughMs(dateProfile.slotMinTime) &&\n        timeMs < asRoughMs(dateProfile.slotMaxTime)\n      ) {\n        return this.computeTimeTop(createDuration(timeMs))\n      }\n    }\n\n    return null\n  }\n\n  // Computes the top coordinate, relative to the bounds of the grid, of the given date.\n  // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.\n  computeDateTop(when: DateMarker, startOfDayDate?: DateMarker) {\n    if (!startOfDayDate) {\n      startOfDayDate = startOfDay(when)\n    }\n    return this.computeTimeTop(createDuration(when.valueOf() - startOfDayDate.valueOf()))\n  }\n\n  // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).\n  // This is a makeshify way to compute the time-top. Assumes all slatMetas dates are uniform.\n  // Eventually allow computation with arbirary slat dates.\n  computeTimeTop(duration: Duration): number {\n    let { positions, dateProfile } = this\n    let len = positions.els.length\n\n    // floating-point value of # of slots covered\n    let slatCoverage = (duration.milliseconds - asRoughMs(dateProfile.slotMinTime)) / asRoughMs(this.slotDuration)\n    let slatIndex\n    let slatRemainder\n\n    // compute a floating-point number for how many slats should be progressed through.\n    // from 0 to number of slats (inclusive)\n    // constrained because slotMinTime/slotMaxTime might be customized.\n    slatCoverage = Math.max(0, slatCoverage)\n    slatCoverage = Math.min(len, slatCoverage)\n\n    // an integer index of the furthest whole slat\n    // from 0 to number slats (*exclusive*, so len-1)\n    slatIndex = Math.floor(slatCoverage)\n    slatIndex = Math.min(slatIndex, len - 1)\n\n    // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.\n    // could be 1.0 if slatCoverage is covering *all* the slots\n    slatRemainder = slatCoverage - slatIndex\n\n    return positions.tops[slatIndex] +\n      positions.getHeight(slatIndex) * slatRemainder\n  }\n}\n","import {\n  createElement,\n  BaseComponent,\n  RefMap,\n  RenderHook,\n  SlotLaneContentArg,\n} from '@fullcalendar/common'\nimport { TimeColsAxisCell } from './TimeColsAxisCell'\nimport { TimeSlatMeta } from './time-slat-meta'\n\nexport interface TimeColsSlatsBodyProps {\n  axis: boolean\n  slatMetas: TimeSlatMeta[]\n  slatElRefs: RefMap<HTMLTableRowElement>\n}\n\nexport class TimeColsSlatsBody extends BaseComponent<TimeColsSlatsBodyProps> {\n  render() {\n    let { props, context } = this\n    let { options } = context\n    let { slatElRefs } = props\n\n    return (\n      <tbody>\n        {props.slatMetas.map((slatMeta, i) => {\n          let hookProps: SlotLaneContentArg = {\n            time: slatMeta.time,\n            date: context.dateEnv.toDate(slatMeta.date),\n            view: context.viewApi,\n          }\n\n          let classNames = [\n            'fc-timegrid-slot',\n            'fc-timegrid-slot-lane',\n            slatMeta.isLabeled ? '' : 'fc-timegrid-slot-minor',\n          ]\n\n          return (\n            <tr\n              key={slatMeta.key}\n              ref={slatElRefs.createRef(slatMeta.key)}\n            >\n              {props.axis && (\n                <TimeColsAxisCell {...slatMeta} />\n              )}\n              <RenderHook\n                hookProps={hookProps}\n                classNames={options.slotLaneClassNames}\n                content={options.slotLaneContent}\n                didMount={options.slotLaneDidMount}\n                willUnmount={options.slotLaneWillUnmount}\n              >\n                {(rootElRef, customClassNames, innerElRef, innerContent) => (\n                  <td\n                    ref={rootElRef}\n                    className={classNames.concat(customClassNames).join(' ')}\n                    data-time={slatMeta.isoTimeStr}\n                  >\n                    {innerContent}\n                  </td>\n                )}\n              </RenderHook>\n            </tr>\n          )\n        })}\n      </tbody>\n    )\n  }\n}\n","import {\n  createElement,\n  VNode,\n  BaseComponent,\n  RefMap,\n  CssDimValue,\n  createRef,\n  PositionCache,\n  DateProfile,\n} from '@fullcalendar/common'\nimport { TimeSlatMeta } from './time-slat-meta'\nimport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\nimport { TimeColsSlatsBody } from './TimeColsSlatsBody'\n\nexport interface TimeColsSlatsProps extends TimeColsSlatsContentProps {\n  dateProfile: DateProfile\n  clientWidth: number | null\n  minHeight: CssDimValue\n  tableMinWidth: CssDimValue\n  tableColGroupNode: VNode\n  onCoords?: (coords: TimeColsSlatsCoords | null) => void\n}\n\ninterface TimeColsSlatsContentProps {\n  axis: boolean\n  slatMetas: TimeSlatMeta[]\n}\n\n/*\nfor the horizontal \"slats\" that run width-wise. Has a time axis on a side. Depends on RTL.\n*/\n\nexport class TimeColsSlats extends BaseComponent<TimeColsSlatsProps> {\n  private rootElRef = createRef<HTMLDivElement>()\n  private slatElRefs = new RefMap<HTMLTableRowElement>()\n\n  render() {\n    let { props, context } = this\n\n    return (\n      <div ref={this.rootElRef} className=\"fc-timegrid-slots\">\n        <table\n          aria-hidden\n          className={context.theme.getClass('table')}\n          style={{\n            minWidth: props.tableMinWidth,\n            width: props.clientWidth,\n            height: props.minHeight,\n          }}\n        >\n          {props.tableColGroupNode /* relies on there only being a single <col> for the axis */}\n          <TimeColsSlatsBody\n            slatElRefs={this.slatElRefs}\n            axis={props.axis}\n            slatMetas={props.slatMetas}\n          />\n        </table>\n      </div>\n    )\n  }\n\n  componentDidMount() {\n    this.updateSizing()\n  }\n\n  componentDidUpdate() {\n    this.updateSizing()\n  }\n\n  componentWillUnmount() {\n    if (this.props.onCoords) {\n      this.props.onCoords(null)\n    }\n  }\n\n  updateSizing() {\n    let { context, props } = this\n\n    if (\n      props.onCoords &&\n      props.clientWidth !== null // means sizing has stabilized\n    ) {\n      let rootEl = this.rootElRef.current\n\n      if (rootEl.offsetHeight) { // not hidden by css\n        props.onCoords(\n          new TimeColsSlatsCoords(\n            new PositionCache(\n              this.rootElRef.current,\n              collectSlatEls(this.slatElRefs.currentMap, props.slatMetas),\n              false,\n              true, // vertical\n            ),\n            this.props.dateProfile,\n            context.options.slotDuration,\n          ),\n        )\n      }\n    }\n  }\n}\n\nfunction collectSlatEls(elMap: { [key: string]: HTMLElement }, slatMetas: TimeSlatMeta[]) {\n  return slatMetas.map((slatMeta) => elMap[slatMeta.key])\n}\n","import { DateMarker, Seg, EventSegUiInteractionState } from '@fullcalendar/common'\n\n// JUST A DATA STRUCTURE, not a component\n\nexport interface TimeColsSeg extends Seg {\n  col: number\n  start: DateMarker\n  end: DateMarker\n}\n\nexport function splitSegsByCol(segs: TimeColsSeg[] | null, colCnt: number) { // can be given null/undefined!\n  let segsByCol: TimeColsSeg[][] = []\n  let i\n\n  for (i = 0; i < colCnt; i += 1) {\n    segsByCol.push([])\n  }\n\n  if (segs) {\n    for (i = 0; i < segs.length; i += 1) {\n      segsByCol[segs[i].col].push(segs[i])\n    }\n  }\n\n  return segsByCol\n}\n\nexport function splitInteractionByCol(ui: EventSegUiInteractionState | null, colCnt: number) {\n  let byRow: EventSegUiInteractionState[] = []\n\n  if (!ui) {\n    for (let i = 0; i < colCnt; i += 1) {\n      byRow[i] = null\n    }\n  } else {\n    for (let i = 0; i < colCnt; i += 1) {\n      byRow[i] = {\n        affectedInstances: ui.affectedInstances,\n        isEvent: ui.isEvent,\n        segs: [],\n      }\n    }\n\n    for (let seg of ui.segs) {\n      byRow[seg.col].segs.push(seg)\n    }\n  }\n\n  return byRow\n}\n","import {\n  createElement, MoreLinkContentArg, MoreLinkRoot, BaseComponent, createRef, setRef,\n  Dictionary, DateProfile, DateRange, DateMarker, EventSegUiInteractionState, CssDimValue,\n} from '@fullcalendar/common'\nimport { renderPlainFgSegs } from './TimeCol'\nimport { TimeColsSeg } from './TimeColsSeg'\n\nexport interface TimeColMoreLinkProps {\n  hiddenSegs: TimeColsSeg[]\n  top: CssDimValue\n  bottom: CssDimValue\n  extraDateSpan?: Dictionary\n  dateProfile: DateProfile\n  todayRange: DateRange\n  nowDate: DateMarker\n  eventSelection: string\n  eventDrag: EventSegUiInteractionState\n  eventResize: EventSegUiInteractionState\n}\n\nexport class TimeColMoreLink extends BaseComponent<TimeColMoreLinkProps> {\n  rootElRef = createRef<HTMLElement>()\n\n  render() {\n    let { props } = this\n    return (\n      <MoreLinkRoot\n        allDayDate={null}\n        moreCnt={props.hiddenSegs.length}\n        allSegs={props.hiddenSegs}\n        hiddenSegs={props.hiddenSegs}\n        alignmentElRef={this.rootElRef}\n        defaultContent={renderMoreLinkInner}\n        extraDateSpan={props.extraDateSpan}\n        dateProfile={props.dateProfile}\n        todayRange={props.todayRange}\n        popoverContent={() => renderPlainFgSegs(props.hiddenSegs, props)}\n      >\n        {(rootElRef, classNames, innerElRef, innerContent, handleClick, title, isExpanded, popoverId) => (\n          <a\n            ref={(el: HTMLElement | null) => {\n              setRef(rootElRef, el)\n              setRef(this.rootElRef, el)\n            }}\n            className={['fc-timegrid-more-link'].concat(classNames).join(' ')}\n            style={{ top: props.top, bottom: props.bottom }}\n            onClick={handleClick}\n            title={title}\n            aria-expanded={isExpanded}\n            aria-controls={popoverId}\n          >\n            <div ref={innerElRef} className=\"fc-timegrid-more-link-inner fc-sticky\">\n              {innerContent}\n            </div>\n          </a>\n        )}\n      </MoreLinkRoot>\n    )\n  }\n}\n\nfunction renderMoreLinkInner(props: MoreLinkContentArg) {\n  return props.shortText\n}\n","import {\n  SegEntry,\n  SegHierarchy,\n  SegRect,\n  buildEntryKey,\n  getEntrySpanEnd,\n  binarySearch,\n  SegEntryGroup,\n  groupIntersectingEntries,\n} from '@fullcalendar/common'\n\ninterface SegNode extends SegEntry {\n  nextLevelNodes: SegNode[] // with highest-pressure first\n}\n\ntype SegNodeAndPressure = [ SegNode, number ]\n\ninterface SegSiblingRange { // will ALWAYS have span of 1 or more items. if not, will be null\n  level: number\n  lateralStart: number\n  lateralEnd: number\n}\n\nexport interface SegWebRect extends SegRect {\n  stackDepth: number\n  stackForward: number\n}\n\n// segInputs assumed sorted\nexport function buildPositioning(\n  segInputs: SegEntry[],\n  strictOrder?: boolean,\n  maxStackCnt?: number,\n): { segRects: SegWebRect[], hiddenGroups: SegEntryGroup[] } {\n  let hierarchy = new SegHierarchy()\n  if (strictOrder != null) {\n    hierarchy.strictOrder = strictOrder\n  }\n  if (maxStackCnt != null) {\n    hierarchy.maxStackCnt = maxStackCnt\n  }\n\n  let hiddenEntries = hierarchy.addSegs(segInputs)\n  let hiddenGroups = groupIntersectingEntries(hiddenEntries)\n\n  let web = buildWeb(hierarchy)\n  web = stretchWeb(web, 1) // all levelCoords/thickness will have 0.0-1.0\n  let segRects = webToRects(web)\n\n  return { segRects, hiddenGroups }\n}\n\nfunction buildWeb(hierarchy: SegHierarchy): SegNode[] {\n  const { entriesByLevel } = hierarchy\n\n  const buildNode = cacheable(\n    (level: number, lateral: number) => level + ':' + lateral,\n    (level: number, lateral: number): SegNodeAndPressure => {\n      let siblingRange = findNextLevelSegs(hierarchy, level, lateral)\n      let nextLevelRes = buildNodes(siblingRange, buildNode)\n      let entry = entriesByLevel[level][lateral]\n\n      return [\n        { ...entry, nextLevelNodes: nextLevelRes[0] },\n        entry.thickness + nextLevelRes[1], // the pressure builds\n      ]\n    },\n  )\n\n  return buildNodes(\n    entriesByLevel.length\n      ? { level: 0, lateralStart: 0, lateralEnd: entriesByLevel[0].length }\n      : null,\n    buildNode,\n  )[0]\n}\n\nfunction buildNodes(\n  siblingRange: SegSiblingRange | null,\n  buildNode: (level: number, lateral: number) => SegNodeAndPressure,\n): [SegNode[], number] { // number is maxPressure\n  if (!siblingRange) {\n    return [[], 0]\n  }\n\n  let { level, lateralStart, lateralEnd } = siblingRange\n  let lateral = lateralStart\n  let pairs: SegNodeAndPressure[] = []\n\n  while (lateral < lateralEnd) {\n    pairs.push(buildNode(level, lateral))\n    lateral += 1\n  }\n\n  pairs.sort(cmpDescPressures)\n\n  return [\n    pairs.map(extractNode),\n    pairs[0][1], // first item's pressure\n  ]\n}\n\nfunction cmpDescPressures(a: SegNodeAndPressure, b: SegNodeAndPressure) { // sort pressure high -> low\n  return b[1] - a[1]\n}\n\nfunction extractNode(a: SegNodeAndPressure): SegNode {\n  return a[0]\n}\n\nfunction findNextLevelSegs(hierarchy: SegHierarchy, subjectLevel: number, subjectLateral: number): SegSiblingRange | null {\n  let { levelCoords, entriesByLevel } = hierarchy\n  let subjectEntry = entriesByLevel[subjectLevel][subjectLateral]\n  let afterSubject = levelCoords[subjectLevel] + subjectEntry.thickness\n  let levelCnt = levelCoords.length\n  let level = subjectLevel\n\n  // skip past levels that are too high up\n  for (; level < levelCnt && levelCoords[level] < afterSubject; level += 1) ; // do nothing\n\n  for (; level < levelCnt; level += 1) {\n    let entries = entriesByLevel[level]\n    let entry: SegEntry\n    let searchIndex = binarySearch(entries, subjectEntry.span.start, getEntrySpanEnd)\n    let lateralStart = searchIndex[0] + searchIndex[1] // if exact match (which doesn't collide), go to next one\n    let lateralEnd = lateralStart\n\n    while ( // loop through entries that horizontally intersect\n      (entry = entries[lateralEnd]) && // but not past the whole seg list\n      entry.span.start < subjectEntry.span.end\n    ) { lateralEnd += 1 }\n\n    if (lateralStart < lateralEnd) {\n      return { level, lateralStart, lateralEnd }\n    }\n  }\n\n  return null\n}\n\nfunction stretchWeb(topLevelNodes: SegNode[], totalThickness: number): SegNode[] {\n  const stretchNode = cacheable(\n    (node: SegNode, startCoord: number, prevThickness: number) => buildEntryKey(node),\n    (node: SegNode, startCoord: number, prevThickness: number): [number, SegNode] => { // [startCoord, node]\n      let { nextLevelNodes, thickness } = node\n      let allThickness = thickness + prevThickness\n      let thicknessFraction = thickness / allThickness\n      let endCoord: number\n      let newChildren: SegNode[] = []\n\n      if (!nextLevelNodes.length) {\n        endCoord = totalThickness\n      } else {\n        for (let childNode of nextLevelNodes) {\n          if (endCoord === undefined) {\n            let res = stretchNode(childNode, startCoord, allThickness)\n            endCoord = res[0]\n            newChildren.push(res[1])\n          } else {\n            let res = stretchNode(childNode, endCoord, 0)\n            newChildren.push(res[1])\n          }\n        }\n      }\n\n      let newThickness = (endCoord - startCoord) * thicknessFraction\n      return [endCoord - newThickness, {\n        ...node,\n        thickness: newThickness,\n        nextLevelNodes: newChildren,\n      }]\n    },\n  )\n\n  return topLevelNodes.map((node: SegNode) => stretchNode(node, 0, 0)[1])\n}\n\n// not sorted in any particular order\nfunction webToRects(topLevelNodes: SegNode[]): SegWebRect[] {\n  let rects: SegWebRect[] = []\n\n  const processNode = cacheable(\n    (node: SegNode, levelCoord: number, stackDepth: number) => buildEntryKey(node),\n    (node: SegNode, levelCoord: number, stackDepth: number) => { // returns forwardPressure\n      let rect: SegWebRect = {\n        ...node,\n        levelCoord,\n        stackDepth,\n        stackForward: 0, // will assign after recursing\n      }\n      rects.push(rect)\n\n      return (\n        rect.stackForward = processNodes(node.nextLevelNodes, levelCoord + node.thickness, stackDepth + 1) + 1\n      )\n    },\n  )\n\n  function processNodes(nodes: SegNode[], levelCoord: number, stackDepth: number) { // returns stackForward\n    let stackForward = 0\n    for (let node of nodes) {\n      stackForward = Math.max(processNode(node, levelCoord, stackDepth), stackForward)\n    }\n    return stackForward\n  }\n\n  processNodes(topLevelNodes, 0, 0)\n  return rects // TODO: sort rects by levelCoord to be consistent with toRects?\n}\n\n// TODO: move to general util\n\nfunction cacheable<Args extends any[], Res>(\n  keyFunc: (...args: Args) => string,\n  workFunc: (...args: Args) => Res,\n): ((...args: Args) => Res) {\n  const cache: { [key: string]: Res } = {}\n\n  return (...args: Args) => {\n    let key = keyFunc(...args)\n    return (key in cache)\n      ? cache[key]\n      : (cache[key] = workFunc(...args))\n  }\n}\n","import {\n  SegSpan,\n  SegEntry,\n  SegEntryGroup,\n  DateMarker,\n} from '@fullcalendar/common'\nimport { TimeColsSeg } from './TimeColsSeg'\nimport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\nimport { SegWebRect, buildPositioning } from './seg-web'\n\n// public interface\n// ------------------------------------------------------------------------------------------\n\nexport interface TimeColFgSegPlacement {\n  seg: TimeColsSeg\n  rect: SegWebRect | null\n}\n\nexport function computeSegVCoords(\n  segs: TimeColsSeg[],\n  colDate: DateMarker,\n  slatCoords: TimeColsSlatsCoords = null,\n  eventMinHeight: number = 0, // might be null/undefined :(\n): SegSpan[] {\n  let vcoords: SegSpan[] = []\n\n  if (slatCoords) {\n    for (let i = 0; i < segs.length; i += 1) {\n      let seg = segs[i]\n      let spanStart = slatCoords.computeDateTop(seg.start, colDate)\n      let spanEnd = Math.max(\n        spanStart + (eventMinHeight || 0), // :(\n        slatCoords.computeDateTop(seg.end, colDate),\n      )\n      vcoords.push({\n        start: Math.round(spanStart), // for barely-overlapping collisions\n        end: Math.round(spanEnd), //\n      })\n    }\n  }\n\n  return vcoords\n}\n\nexport function computeFgSegPlacements(\n  segs: TimeColsSeg[],\n  segVCoords: SegSpan[], // might not have for every seg\n  eventOrderStrict?: boolean,\n  eventMaxStack?: number,\n): { segPlacements: TimeColFgSegPlacement[], hiddenGroups: SegEntryGroup[] } {\n  let segInputs: SegEntry[] = []\n  let dumbSegs: TimeColsSeg[] = [] // segs without coords\n\n  for (let i = 0; i < segs.length; i += 1) {\n    let vcoords = segVCoords[i]\n    if (vcoords) {\n      segInputs.push({\n        index: i,\n        thickness: 1,\n        span: vcoords,\n      })\n    } else {\n      dumbSegs.push(segs[i])\n    }\n  }\n\n  let { segRects, hiddenGroups } = buildPositioning(segInputs, eventOrderStrict, eventMaxStack)\n  let segPlacements: TimeColFgSegPlacement[] = []\n\n  for (let segRect of segRects) {\n    segPlacements.push({\n      seg: segs[segRect.index],\n      rect: segRect,\n    })\n  }\n\n  for (let dumbSeg of dumbSegs) {\n    segPlacements.push({ seg: dumbSeg, rect: null })\n  }\n\n  return { segPlacements, hiddenGroups }\n}\n","import { createElement, StandardEvent, BaseComponent, MinimalEventProps, createFormatter } from '@fullcalendar/common'\n\nconst DEFAULT_TIME_FORMAT = createFormatter({\n  hour: 'numeric',\n  minute: '2-digit',\n  meridiem: false,\n})\n\nexport interface TimeColEventProps extends MinimalEventProps {\n  isShort: boolean\n}\n\nexport class TimeColEvent extends BaseComponent<TimeColEventProps> {\n  render() {\n    let classNames = [\n      'fc-timegrid-event',\n      'fc-v-event',\n    ]\n\n    if (this.props.isShort) {\n      classNames.push('fc-timegrid-event-short')\n    }\n\n    return (\n      <StandardEvent\n        {...this.props}\n        defaultTimeFormat={DEFAULT_TIME_FORMAT}\n        extraClassNames={classNames}\n      />\n    )\n  }\n}\n","import {\n  DateMarker, BaseComponent, createElement,\n  DateRange, DayCellContent, DateProfile,\n} from '@fullcalendar/common'\n\nexport interface TimeColMiscProps { // should be given nowDate too??\n  dateProfile: DateProfile\n  date: DateMarker\n  todayRange: DateRange\n  extraHookProps?: any\n}\n\nexport class TimeColMisc extends BaseComponent<TimeColMiscProps> {\n  render() {\n    let { props } = this\n\n    return (\n      <DayCellContent date={props.date} dateProfile={props.dateProfile} todayRange={props.todayRange} extraHookProps={props.extraHookProps}>\n        {(innerElRef, innerContent) => (\n          innerContent &&\n            <div className=\"fc-timegrid-col-misc\" ref={innerElRef}>{innerContent}</div>\n        )}\n      </DayCellContent>\n    )\n  }\n}\n","import {\n  Ref, DateMarker, BaseComponent, createElement, EventSegUiInteractionState, Seg, getSegMeta,\n  DateRange, Fragment, DayCellRoot, NowIndicatorRoot, BgEvent, renderFill, buildIsoString, computeEarliestSegStart,\n  DateProfile, buildEventRangeKey, sortEventSegs, memoize, SegEntryGroup, SegEntry, Dictionary, SegSpan, CssDimValue,\n} from '@fullcalendar/common'\nimport { TimeColMoreLink } from './TimeColMoreLink'\nimport { TimeColsSeg } from './TimeColsSeg'\nimport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\nimport { SegWebRect } from './seg-web'\nimport { computeFgSegPlacements, computeSegVCoords } from './event-placement'\nimport { TimeColEvent } from './TimeColEvent'\nimport { TimeColMisc } from './TimeColMisc'\n\nexport interface TimeColProps {\n  elRef?: Ref<HTMLTableCellElement>\n  dateProfile: DateProfile\n  date: DateMarker\n  nowDate: DateMarker\n  todayRange: DateRange\n  extraDataAttrs?: any\n  extraHookProps?: any\n  extraClassNames?: string[]\n  extraDateSpan?: Dictionary\n  fgEventSegs: TimeColsSeg[]\n  bgEventSegs: TimeColsSeg[]\n  businessHourSegs: TimeColsSeg[]\n  nowIndicatorSegs: TimeColsSeg[]\n  dateSelectionSegs: TimeColsSeg[]\n  eventSelection: string\n  eventDrag: EventSegUiInteractionState | null\n  eventResize: EventSegUiInteractionState | null\n  slatCoords: TimeColsSlatsCoords\n  forPrint: boolean\n}\n\nexport class TimeCol extends BaseComponent<TimeColProps> {\n  sortEventSegs = memoize(sortEventSegs)\n  // TODO: memoize event-placement?\n\n  render() {\n    let { props, context } = this\n    let isSelectMirror = context.options.selectMirror\n\n    let mirrorSegs: Seg[] = // yuck\n      (props.eventDrag && props.eventDrag.segs) ||\n      (props.eventResize && props.eventResize.segs) ||\n      (isSelectMirror && props.dateSelectionSegs) ||\n      []\n\n    let interactionAffectedInstances = // TODO: messy way to compute this\n      (props.eventDrag && props.eventDrag.affectedInstances) ||\n      (props.eventResize && props.eventResize.affectedInstances) ||\n      {}\n\n    let sortedFgSegs = this.sortEventSegs(props.fgEventSegs, context.options.eventOrder) as TimeColsSeg[]\n\n    return (\n      <DayCellRoot\n        elRef={props.elRef}\n        date={props.date}\n        dateProfile={props.dateProfile}\n        todayRange={props.todayRange}\n        extraHookProps={props.extraHookProps}\n      >\n        {(rootElRef, classNames, dataAttrs) => (\n          <td\n            ref={rootElRef}\n            role=\"gridcell\"\n            className={['fc-timegrid-col'].concat(classNames, props.extraClassNames || []).join(' ')}\n            {...dataAttrs}\n            {...props.extraDataAttrs}\n          >\n            <div className=\"fc-timegrid-col-frame\">\n              <div className=\"fc-timegrid-col-bg\">\n                {this.renderFillSegs(props.businessHourSegs, 'non-business')}\n                {this.renderFillSegs(props.bgEventSegs, 'bg-event')}\n                {this.renderFillSegs(props.dateSelectionSegs, 'highlight')}\n              </div>\n              <div className=\"fc-timegrid-col-events\">\n                {this.renderFgSegs(\n                  sortedFgSegs,\n                  interactionAffectedInstances,\n                  false,\n                  false,\n                  false,\n                )}\n              </div>\n              <div className=\"fc-timegrid-col-events\">\n                {this.renderFgSegs(\n                  mirrorSegs as TimeColsSeg[],\n                  {},\n                  Boolean(props.eventDrag),\n                  Boolean(props.eventResize),\n                  Boolean(isSelectMirror),\n                )}\n              </div>\n              <div className=\"fc-timegrid-now-indicator-container\">\n                {this.renderNowIndicator(props.nowIndicatorSegs)}\n              </div>\n              <TimeColMisc\n                date={props.date}\n                dateProfile={props.dateProfile}\n                todayRange={props.todayRange}\n                extraHookProps={props.extraHookProps}\n              />\n            </div>\n          </td>\n        )}\n      </DayCellRoot>\n    )\n  }\n\n  renderFgSegs(\n    sortedFgSegs: TimeColsSeg[],\n    segIsInvisible: { [instanceId: string]: any },\n    isDragging: boolean,\n    isResizing: boolean,\n    isDateSelecting: boolean,\n  ) {\n    let { props } = this\n    if (props.forPrint) {\n      return renderPlainFgSegs(sortedFgSegs, props)\n    }\n    return this.renderPositionedFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting)\n  }\n\n  renderPositionedFgSegs(\n    segs: TimeColsSeg[], // if not mirror, needs to be sorted\n    segIsInvisible: { [instanceId: string]: any },\n    isDragging: boolean,\n    isResizing: boolean,\n    isDateSelecting: boolean,\n  ) {\n    let { eventMaxStack, eventShortHeight, eventOrderStrict, eventMinHeight } = this.context.options\n    let { date, slatCoords, eventSelection, todayRange, nowDate } = this.props\n    let isMirror = isDragging || isResizing || isDateSelecting\n    let segVCoords = computeSegVCoords(segs, date, slatCoords, eventMinHeight)\n    let { segPlacements, hiddenGroups } = computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack)\n\n    return (\n      <Fragment>\n        {this.renderHiddenGroups(hiddenGroups, segs)}\n        {segPlacements.map((segPlacement) => {\n          let { seg, rect } = segPlacement\n          let instanceId = seg.eventRange.instance.instanceId\n          let isVisible = isMirror || Boolean(!segIsInvisible[instanceId] && rect)\n          let vStyle = computeSegVStyle(rect && rect.span)\n          let hStyle = (!isMirror && rect) ? this.computeSegHStyle(rect) : { left: 0, right: 0 }\n          let isInset = Boolean(rect) && rect.stackForward > 0\n          let isShort = Boolean(rect) && (rect.span.end - rect.span.start) < eventShortHeight // look at other places for this problem\n\n          return (\n            <div\n              className={\n                'fc-timegrid-event-harness' +\n                (isInset ? ' fc-timegrid-event-harness-inset' : '')\n              }\n              key={instanceId}\n              style={{\n                visibility: isVisible ? ('' as any) : 'hidden',\n                ...vStyle,\n                ...hStyle,\n              }}\n            >\n              <TimeColEvent\n                seg={seg}\n                isDragging={isDragging}\n                isResizing={isResizing}\n                isDateSelecting={isDateSelecting}\n                isSelected={instanceId === eventSelection}\n                isShort={isShort}\n                {...getSegMeta(seg, todayRange, nowDate)}\n              />\n            </div>\n          )\n        })}\n      </Fragment>\n    )\n  }\n\n  // will already have eventMinHeight applied because segInputs already had it\n  renderHiddenGroups(hiddenGroups: SegEntryGroup[], segs: TimeColsSeg[]) {\n    let { extraDateSpan, dateProfile, todayRange, nowDate, eventSelection, eventDrag, eventResize } = this.props\n    return (\n      <Fragment>\n        {hiddenGroups.map((hiddenGroup) => {\n          let positionCss = computeSegVStyle(hiddenGroup.span)\n          let hiddenSegs = compileSegsFromEntries(hiddenGroup.entries, segs)\n          return (\n            <TimeColMoreLink\n              key={buildIsoString(computeEarliestSegStart(hiddenSegs))}\n              hiddenSegs={hiddenSegs}\n              top={positionCss.top}\n              bottom={positionCss.bottom}\n              extraDateSpan={extraDateSpan}\n              dateProfile={dateProfile}\n              todayRange={todayRange}\n              nowDate={nowDate}\n              eventSelection={eventSelection}\n              eventDrag={eventDrag}\n              eventResize={eventResize}\n            />\n          )\n        })}\n      </Fragment>\n    )\n  }\n\n  renderFillSegs(segs: TimeColsSeg[], fillType: string) {\n    let { props, context } = this\n    let segVCoords = computeSegVCoords(segs, props.date, props.slatCoords, context.options.eventMinHeight) // don't assume all populated\n\n    let children = segVCoords.map((vcoords, i) => {\n      let seg = segs[i]\n      return (\n        <div\n          key={buildEventRangeKey(seg.eventRange)}\n          className=\"fc-timegrid-bg-harness\"\n          style={computeSegVStyle(vcoords)}\n        >\n          {fillType === 'bg-event' ?\n            <BgEvent seg={seg} {...getSegMeta(seg, props.todayRange, props.nowDate)} /> :\n            renderFill(fillType)}\n        </div>\n      )\n    })\n\n    return <Fragment>{children}</Fragment>\n  }\n\n  renderNowIndicator(segs: TimeColsSeg[]) {\n    let { slatCoords, date } = this.props\n\n    if (!slatCoords) { return null }\n\n    return segs.map((seg, i) => (\n      <NowIndicatorRoot\n        isAxis={false}\n        date={date}\n        // key doesn't matter. will only ever be one\n        key={i} // eslint-disable-line react/no-array-index-key\n      >\n        {(rootElRef, classNames, innerElRef, innerContent) => (\n          <div\n            ref={rootElRef}\n            className={['fc-timegrid-now-indicator-line'].concat(classNames).join(' ')}\n            style={{ top: slatCoords.computeDateTop(seg.start, date) }}\n          >\n            {innerContent}\n          </div>\n        )}\n      </NowIndicatorRoot>\n    ))\n  }\n\n  computeSegHStyle(segHCoords: SegWebRect) {\n    let { isRtl, options } = this.context\n    let shouldOverlap = options.slotEventOverlap\n    let nearCoord = segHCoords.levelCoord // the left side if LTR. the right side if RTL. floating-point\n    let farCoord = segHCoords.levelCoord + segHCoords.thickness // the right side if LTR. the left side if RTL. floating-point\n    let left // amount of space from left edge, a fraction of the total width\n    let right // amount of space from right edge, a fraction of the total width\n\n    if (shouldOverlap) {\n      // double the width, but don't go beyond the maximum forward coordinate (1.0)\n      farCoord = Math.min(1, nearCoord + (farCoord - nearCoord) * 2)\n    }\n\n    if (isRtl) {\n      left = 1 - farCoord\n      right = nearCoord\n    } else {\n      left = nearCoord\n      right = 1 - farCoord\n    }\n\n    let props = {\n      zIndex: segHCoords.stackDepth + 1, // convert from 0-base to 1-based\n      left: left * 100 + '%',\n      right: right * 100 + '%',\n    }\n\n    if (shouldOverlap && !segHCoords.stackForward) {\n      // add padding to the edge so that forward stacked events don't cover the resizer's icon\n      props[isRtl ? 'marginLeft' : 'marginRight'] = 10 * 2 // 10 is a guesstimate of the icon's width\n    }\n\n    return props\n  }\n}\n\nexport function renderPlainFgSegs(\n  sortedFgSegs: TimeColsSeg[],\n  { todayRange, nowDate, eventSelection, eventDrag, eventResize }: {\n    todayRange: DateRange\n    nowDate: DateMarker\n    eventSelection: string\n    eventDrag: EventSegUiInteractionState | null\n    eventResize: EventSegUiInteractionState | null\n  },\n) {\n  let hiddenInstances =\n    (eventDrag ? eventDrag.affectedInstances : null) ||\n    (eventResize ? eventResize.affectedInstances : null) ||\n    {}\n  return (\n    <Fragment>\n      {sortedFgSegs.map((seg) => {\n        let instanceId = seg.eventRange.instance.instanceId\n        return (\n          <div\n            key={instanceId}\n            style={{ visibility: hiddenInstances[instanceId] ? 'hidden' : ('' as any) }}\n          >\n            <TimeColEvent\n              seg={seg}\n              isDragging={false}\n              isResizing={false}\n              isDateSelecting={false}\n              isSelected={instanceId === eventSelection}\n              isShort={false}\n              {...getSegMeta(seg, todayRange, nowDate)}\n            />\n          </div>\n        )\n      })}\n    </Fragment>\n  )\n}\n\nfunction computeSegVStyle(segVCoords: SegSpan | null): { top: CssDimValue, bottom: CssDimValue } {\n  if (!segVCoords) {\n    return { top: '', bottom: '' }\n  }\n  return {\n    top: segVCoords.start,\n    bottom: -segVCoords.end,\n  }\n}\n\nfunction compileSegsFromEntries(\n  segEntries: SegEntry[],\n  allSegs: TimeColsSeg[],\n): TimeColsSeg[] {\n  return segEntries.map((segEntry) => allSegs[segEntry.index])\n}\n","import {\n  createElement, VNode,\n  BaseComponent,\n  EventSegUiInteractionState,\n  CssDimValue,\n  DateMarker,\n  RefMap,\n  createRef,\n  PositionCache,\n  memoize,\n  DateRange,\n  NowIndicatorRoot,\n  DateProfile,\n  DayTableCell,\n} from '@fullcalendar/common'\nimport { TimeColsSeg, splitSegsByCol, splitInteractionByCol } from './TimeColsSeg'\nimport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\nimport { TimeCol } from './TimeCol'\n\nexport interface TimeColsContentProps {\n  axis: boolean\n  cells: DayTableCell[]\n  dateProfile: DateProfile\n  nowDate: DateMarker\n  todayRange: DateRange\n  businessHourSegs: TimeColsSeg[]\n  bgEventSegs: TimeColsSeg[]\n  fgEventSegs: TimeColsSeg[]\n  dateSelectionSegs: TimeColsSeg[]\n  eventSelection: string\n  eventDrag: EventSegUiInteractionState | null\n  eventResize: EventSegUiInteractionState | null\n  nowIndicatorSegs: TimeColsSeg[]\n  clientWidth: number | null\n  tableMinWidth: CssDimValue\n  tableColGroupNode: VNode\n  slatCoords: TimeColsSlatsCoords\n  onColCoords?: (colCoords: PositionCache) => void\n  forPrint: boolean\n}\n\nexport class TimeColsContent extends BaseComponent<TimeColsContentProps> { // TODO: rename\n  private splitFgEventSegs = memoize(splitSegsByCol)\n  private splitBgEventSegs = memoize(splitSegsByCol)\n  private splitBusinessHourSegs = memoize(splitSegsByCol)\n  private splitNowIndicatorSegs = memoize(splitSegsByCol)\n  private splitDateSelectionSegs = memoize(splitSegsByCol)\n  private splitEventDrag = memoize(splitInteractionByCol)\n  private splitEventResize = memoize(splitInteractionByCol)\n  private rootElRef = createRef<HTMLDivElement>()\n  private cellElRefs = new RefMap<HTMLTableCellElement>()\n\n  render() {\n    let { props, context } = this\n    let nowIndicatorTop =\n      context.options.nowIndicator &&\n      props.slatCoords &&\n      props.slatCoords.safeComputeTop(props.nowDate) // might return void\n\n    let colCnt = props.cells.length\n    let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, colCnt)\n    let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, colCnt)\n    let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, colCnt)\n    let nowIndicatorSegsByRow = this.splitNowIndicatorSegs(props.nowIndicatorSegs, colCnt)\n    let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, colCnt)\n    let eventDragByRow = this.splitEventDrag(props.eventDrag, colCnt)\n    let eventResizeByRow = this.splitEventResize(props.eventResize, colCnt)\n\n    return (\n      <div className=\"fc-timegrid-cols\" ref={this.rootElRef}>\n        <table\n          role=\"presentation\"\n          style={{\n            minWidth: props.tableMinWidth,\n            width: props.clientWidth,\n          }}\n        >\n          {props.tableColGroupNode}\n          <tbody role=\"presentation\">\n            <tr role=\"row\">\n              {props.axis && (\n                <td aria-hidden className=\"fc-timegrid-col fc-timegrid-axis\">\n                  <div className=\"fc-timegrid-col-frame\">\n                    <div className=\"fc-timegrid-now-indicator-container\">\n                      {typeof nowIndicatorTop === 'number' && (\n                        <NowIndicatorRoot isAxis date={props.nowDate}>\n                          {(rootElRef, classNames, innerElRef, innerContent) => (\n                            <div\n                              ref={rootElRef}\n                              className={['fc-timegrid-now-indicator-arrow'].concat(classNames).join(' ')}\n                              style={{ top: nowIndicatorTop }}\n                            >\n                              {innerContent}\n                            </div>\n                          )}\n                        </NowIndicatorRoot>\n                      )}\n                    </div>\n                  </div>\n                </td>\n              )}\n              {props.cells.map((cell, i) => (\n                <TimeCol\n                  key={cell.key}\n                  elRef={this.cellElRefs.createRef(cell.key)}\n                  dateProfile={props.dateProfile}\n                  date={cell.date}\n                  nowDate={props.nowDate}\n                  todayRange={props.todayRange}\n                  extraHookProps={cell.extraHookProps}\n                  extraDataAttrs={cell.extraDataAttrs}\n                  extraClassNames={cell.extraClassNames}\n                  extraDateSpan={cell.extraDateSpan}\n                  fgEventSegs={fgEventSegsByRow[i]}\n                  bgEventSegs={bgEventSegsByRow[i]}\n                  businessHourSegs={businessHourSegsByRow[i]}\n                  nowIndicatorSegs={nowIndicatorSegsByRow[i]}\n                  dateSelectionSegs={dateSelectionSegsByRow[i]}\n                  eventDrag={eventDragByRow[i]}\n                  eventResize={eventResizeByRow[i]}\n                  slatCoords={props.slatCoords}\n                  eventSelection={props.eventSelection}\n                  forPrint={props.forPrint}\n                />\n              ))}\n            </tr>\n          </tbody>\n        </table>\n      </div>\n    )\n  }\n\n  componentDidMount() {\n    this.updateCoords()\n  }\n\n  componentDidUpdate() {\n    this.updateCoords()\n  }\n\n  updateCoords() {\n    let { props } = this\n\n    if (\n      props.onColCoords &&\n      props.clientWidth !== null // means sizing has stabilized\n    ) {\n      props.onColCoords(\n        new PositionCache(\n          this.rootElRef.current,\n          collectCellEls(this.cellElRefs.currentMap, props.cells),\n          true, // horizontal\n          false,\n        ),\n      )\n    }\n  }\n}\n\nfunction collectCellEls(elMap: { [key: string]: HTMLElement }, cells: DayTableCell[]) {\n  return cells.map((cell) => elMap[cell.key])\n}\n","import {\n  createElement, VNode,\n  addDurations,\n  multiplyDuration,\n  wholeDivideDurations,\n  DateMarker,\n  EventSegUiInteractionState,\n  memoize,\n  CssDimValue,\n  PositionCache,\n  ScrollResponder,\n  ScrollRequest,\n  DateRange,\n  Duration,\n  DateProfile,\n  DayTableCell,\n  Hit,\n  DateComponent,\n} from '@fullcalendar/common'\nimport { TimeColsSlats } from './TimeColsSlats'\nimport { TimeSlatMeta } from './time-slat-meta'\nimport { TimeColsContent } from './TimeColsContent'\nimport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\nimport { TimeColsSeg } from './TimeColsSeg'\n\nexport interface TimeColsProps {\n  cells: DayTableCell[]\n  dateProfile: DateProfile\n  slotDuration: Duration\n  nowDate: DateMarker\n  todayRange: DateRange\n  businessHourSegs: TimeColsSeg[]\n  bgEventSegs: TimeColsSeg[]\n  fgEventSegs: TimeColsSeg[]\n  dateSelectionSegs: TimeColsSeg[]\n  eventSelection: string\n  eventDrag: EventSegUiInteractionState | null\n  eventResize: EventSegUiInteractionState | null\n  tableColGroupNode: VNode\n  tableMinWidth: CssDimValue\n  clientWidth: number | null\n  clientHeight: number | null\n  expandRows: boolean\n  nowIndicatorSegs: TimeColsSeg[]\n  onScrollTopRequest?: (scrollTop: number) => void\n  forPrint: boolean\n  axis: boolean\n  slatMetas: TimeSlatMeta[]\n  onSlatCoords?: (slatCoords: TimeColsSlatsCoords) => void\n  isHitComboAllowed?: (hit0: Hit, hit1: Hit) => boolean\n}\n\ninterface TimeColsState {\n  slatCoords: TimeColsSlatsCoords | null\n}\n\n/* A component that renders one or more columns of vertical time slots\n----------------------------------------------------------------------------------------------------------------------*/\n\nexport class TimeCols extends DateComponent<TimeColsProps, TimeColsState> {\n  private processSlotOptions = memoize(processSlotOptions)\n  private scrollResponder: ScrollResponder\n  private colCoords: PositionCache\n\n  state = {\n    slatCoords: null,\n  }\n\n  render() {\n    let { props, state } = this\n\n    return (\n      <div\n        className=\"fc-timegrid-body\"\n        ref={this.handleRootEl}\n        style={{\n          // these props are important to give this wrapper correct dimensions for interactions\n          // TODO: if we set it here, can we avoid giving to inner tables?\n          width: props.clientWidth,\n          minWidth: props.tableMinWidth,\n        }}\n      >\n        <TimeColsSlats\n          axis={props.axis}\n          dateProfile={props.dateProfile}\n          slatMetas={props.slatMetas}\n          clientWidth={props.clientWidth}\n          minHeight={props.expandRows ? props.clientHeight : ''}\n          tableMinWidth={props.tableMinWidth}\n          tableColGroupNode={props.axis ? props.tableColGroupNode : null /* axis depends on the colgroup's shrinking */}\n          onCoords={this.handleSlatCoords}\n        />\n        <TimeColsContent\n          cells={props.cells}\n          axis={props.axis}\n          dateProfile={props.dateProfile}\n          businessHourSegs={props.businessHourSegs}\n          bgEventSegs={props.bgEventSegs}\n          fgEventSegs={props.fgEventSegs}\n          dateSelectionSegs={props.dateSelectionSegs}\n          eventSelection={props.eventSelection}\n          eventDrag={props.eventDrag}\n          eventResize={props.eventResize}\n          todayRange={props.todayRange}\n          nowDate={props.nowDate}\n          nowIndicatorSegs={props.nowIndicatorSegs}\n          clientWidth={props.clientWidth}\n          tableMinWidth={props.tableMinWidth}\n          tableColGroupNode={props.tableColGroupNode}\n          slatCoords={state.slatCoords}\n          onColCoords={this.handleColCoords}\n          forPrint={props.forPrint}\n        />\n      </div>\n    )\n  }\n\n  handleRootEl = (el: HTMLElement | null) => {\n    if (el) {\n      this.context.registerInteractiveComponent(this, {\n        el,\n        isHitComboAllowed: this.props.isHitComboAllowed,\n      })\n    } else {\n      this.context.unregisterInteractiveComponent(this)\n    }\n  }\n\n  componentDidMount() {\n    this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest)\n  }\n\n  componentDidUpdate(prevProps: TimeColsProps) {\n    this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile)\n  }\n\n  componentWillUnmount() {\n    this.scrollResponder.detach()\n  }\n\n  handleScrollRequest = (request: ScrollRequest) => {\n    let { onScrollTopRequest } = this.props\n    let { slatCoords } = this.state\n\n    if (onScrollTopRequest && slatCoords) {\n      if (request.time) {\n        let top = slatCoords.computeTimeTop(request.time)\n        top = Math.ceil(top) // zoom can give weird floating-point values. rather scroll a little bit further\n        if (top) {\n          top += 1 // to overcome top border that slots beyond the first have. looks better\n        }\n\n        onScrollTopRequest(top)\n      }\n\n      return true\n    }\n\n    return false\n  }\n\n  handleColCoords = (colCoords: PositionCache | null) => {\n    this.colCoords = colCoords\n  }\n\n  handleSlatCoords = (slatCoords: TimeColsSlatsCoords | null) => {\n    this.setState({ slatCoords })\n\n    if (this.props.onSlatCoords) {\n      this.props.onSlatCoords(slatCoords)\n    }\n  }\n\n  queryHit(positionLeft: number, positionTop: number): Hit {\n    let { dateEnv, options } = this.context\n    let { colCoords } = this\n    let { dateProfile } = this.props\n    let { slatCoords } = this.state\n    let { snapDuration, snapsPerSlot } = this.processSlotOptions(this.props.slotDuration, options.snapDuration)\n\n    let colIndex = colCoords.leftToIndex(positionLeft)\n    let slatIndex = slatCoords.positions.topToIndex(positionTop)\n\n    if (colIndex != null && slatIndex != null) {\n      let cell = this.props.cells[colIndex]\n      let slatTop = slatCoords.positions.tops[slatIndex]\n      let slatHeight = slatCoords.positions.getHeight(slatIndex)\n      let partial = (positionTop - slatTop) / slatHeight // floating point number between 0 and 1\n      let localSnapIndex = Math.floor(partial * snapsPerSlot) // the snap # relative to start of slat\n      let snapIndex = slatIndex * snapsPerSlot + localSnapIndex\n\n      let dayDate = this.props.cells[colIndex].date\n      let time = addDurations(\n        dateProfile.slotMinTime,\n        multiplyDuration(snapDuration, snapIndex),\n      )\n\n      let start = dateEnv.add(dayDate, time)\n      let end = dateEnv.add(start, snapDuration)\n\n      return {\n        dateProfile,\n        dateSpan: {\n          range: { start, end },\n          allDay: false,\n          ...cell.extraDateSpan,\n        },\n        dayEl: colCoords.els[colIndex],\n        rect: {\n          left: colCoords.lefts[colIndex],\n          right: colCoords.rights[colIndex],\n          top: slatTop,\n          bottom: slatTop + slatHeight,\n        },\n        layer: 0,\n      }\n    }\n\n    return null\n  }\n}\n\nfunction processSlotOptions(slotDuration: Duration, snapDurationOverride: Duration | null) {\n  let snapDuration = snapDurationOverride || slotDuration\n  let snapsPerSlot = wholeDivideDurations(slotDuration, snapDuration)\n\n  if (snapsPerSlot === null) {\n    snapDuration = slotDuration\n    snapsPerSlot = 1\n    // TODO: say warning?\n  }\n\n  return { snapDuration, snapsPerSlot }\n}\n","import { intersectRanges, DateRange, Slicer } from '@fullcalendar/common'\nimport { TimeColsSeg } from './TimeColsSeg'\n\nexport class DayTimeColsSlicer extends Slicer<TimeColsSeg, [DateRange[]]> {\n  sliceRange(range: DateRange, dayRanges: DateRange[]): TimeColsSeg[] {\n    let segs: TimeColsSeg[] = []\n\n    for (let col = 0; col < dayRanges.length; col += 1) {\n      let segRange = intersectRanges(range, dayRanges[col])\n\n      if (segRange) {\n        segs.push({\n          start: segRange.start,\n          end: segRange.end,\n          isStart: segRange.start.valueOf() === range.start.valueOf(),\n          isEnd: segRange.end.valueOf() === range.end.valueOf(),\n          col,\n        })\n      }\n    }\n\n    return segs\n  }\n}\n","import {\n  createElement,\n  createRef,\n  VNode,\n  DateComponent,\n  DateProfile,\n  EventStore,\n  EventUiHash,\n  EventInteractionState,\n  DateSpan,\n  memoize,\n  DateRange,\n  DayTableModel,\n  DateEnv,\n  DateMarker,\n  NowTimer,\n  CssDimValue,\n  Duration,\n} from '@fullcalendar/common'\nimport { TimeCols } from './TimeCols'\nimport { TimeSlatMeta } from './time-slat-meta'\nimport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\nimport { DayTimeColsSlicer } from './DayTimeColsSlicer'\n\nexport interface DayTimeColsProps {\n  dateProfile: DateProfile\n  dayTableModel: DayTableModel\n  axis: boolean\n  slotDuration: Duration\n  slatMetas: TimeSlatMeta[]\n  businessHours: EventStore\n  eventStore: EventStore\n  eventUiBases: EventUiHash\n  dateSelection: DateSpan | null\n  eventSelection: string\n  eventDrag: EventInteractionState | null\n  eventResize: EventInteractionState | null\n  tableColGroupNode: VNode\n  tableMinWidth: CssDimValue\n  clientWidth: number | null\n  clientHeight: number | null\n  expandRows: boolean\n  onScrollTopRequest?: (scrollTop: number) => void\n  forPrint: boolean\n  onSlatCoords?: (slatCoords: TimeColsSlatsCoords) => void\n}\n\nexport class DayTimeCols extends DateComponent<DayTimeColsProps> {\n  private buildDayRanges = memoize(buildDayRanges)\n  private slicer = new DayTimeColsSlicer()\n  private timeColsRef = createRef<TimeCols>()\n\n  render() {\n    let { props, context } = this\n    let { dateProfile, dayTableModel } = props\n\n    let isNowIndicator = context.options.nowIndicator\n    let dayRanges = this.buildDayRanges(dayTableModel, dateProfile, context.dateEnv)\n\n    // give it the first row of cells\n    // TODO: would move this further down hierarchy, but sliceNowDate needs it\n    return (\n      <NowTimer unit={isNowIndicator ? 'minute' : 'day'}>\n        {(nowDate: DateMarker, todayRange: DateRange) => (\n          <TimeCols\n            ref={this.timeColsRef}\n            {...this.slicer.sliceProps(props, dateProfile, null, context, dayRanges)}\n            forPrint={props.forPrint}\n            axis={props.axis}\n            dateProfile={dateProfile}\n            slatMetas={props.slatMetas}\n            slotDuration={props.slotDuration}\n            cells={dayTableModel.cells[0]}\n            tableColGroupNode={props.tableColGroupNode}\n            tableMinWidth={props.tableMinWidth}\n            clientWidth={props.clientWidth}\n            clientHeight={props.clientHeight}\n            expandRows={props.expandRows}\n            nowDate={nowDate}\n            nowIndicatorSegs={isNowIndicator && this.slicer.sliceNowDate(nowDate, context, dayRanges)}\n            todayRange={todayRange}\n            onScrollTopRequest={props.onScrollTopRequest}\n            onSlatCoords={props.onSlatCoords}\n          />\n        )}\n      </NowTimer>\n    )\n  }\n}\n\nexport function buildDayRanges(dayTableModel: DayTableModel, dateProfile: DateProfile, dateEnv: DateEnv): DateRange[] {\n  let ranges: DateRange[] = []\n\n  for (let date of dayTableModel.headerDates) {\n    ranges.push({\n      start: dateEnv.add(date, dateProfile.slotMinTime),\n      end: dateEnv.add(date, dateProfile.slotMaxTime),\n    })\n  }\n\n  return ranges\n}\n","import {\n  createDuration,\n  asRoughMs,\n  formatIsoTimeString,\n  addDurations,\n  wholeDivideDurations,\n  Duration,\n  DateMarker,\n  DateEnv,\n} from '@fullcalendar/common'\n\nexport interface TimeSlatMeta {\n  date: DateMarker\n  time: Duration\n  key: string\n  isoTimeStr: string\n  isLabeled: boolean\n}\n\n// potential nice values for the slot-duration and interval-duration\n// from largest to smallest\nconst STOCK_SUB_DURATIONS = [\n  { hours: 1 },\n  { minutes: 30 },\n  { minutes: 15 },\n  { seconds: 30 },\n  { seconds: 15 },\n]\n\nexport function buildSlatMetas(\n  slotMinTime: Duration,\n  slotMaxTime: Duration,\n  explicitLabelInterval: Duration | null,\n  slotDuration: Duration,\n  dateEnv: DateEnv,\n) {\n  let dayStart = new Date(0)\n  let slatTime = slotMinTime\n  let slatIterator = createDuration(0)\n  let labelInterval = explicitLabelInterval || computeLabelInterval(slotDuration)\n  let metas: TimeSlatMeta[] = []\n\n  while (asRoughMs(slatTime) < asRoughMs(slotMaxTime)) {\n    let date = dateEnv.add(dayStart, slatTime)\n    let isLabeled = wholeDivideDurations(slatIterator, labelInterval) !== null\n\n    metas.push({\n      date,\n      time: slatTime,\n      key: date.toISOString(), // we can't use the isoTimeStr for uniqueness when minTime/maxTime beyone 0h/24h\n      isoTimeStr: formatIsoTimeString(date),\n      isLabeled,\n    })\n\n    slatTime = addDurations(slatTime, slotDuration)\n    slatIterator = addDurations(slatIterator, slotDuration)\n  }\n\n  return metas\n}\n\n// Computes an automatic value for slotLabelInterval\nfunction computeLabelInterval(slotDuration) {\n  let i\n  let labelInterval\n  let slotsPerLabel\n\n  // find the smallest stock label interval that results in more than one slots-per-label\n  for (i = STOCK_SUB_DURATIONS.length - 1; i >= 0; i -= 1) {\n    labelInterval = createDuration(STOCK_SUB_DURATIONS[i])\n    slotsPerLabel = wholeDivideDurations(labelInterval, slotDuration)\n    if (slotsPerLabel !== null && slotsPerLabel > 1) {\n      return labelInterval\n    }\n  }\n\n  return slotDuration // fall back\n}\n","import {\n  createElement,\n  DateProfileGenerator, DateProfile,\n  DayHeader,\n  DaySeriesModel,\n  DayTableModel,\n  memoize,\n  ChunkContentCallbackArgs,\n} from '@fullcalendar/common'\nimport { DayTable } from '@fullcalendar/daygrid'\nimport { TimeColsView } from './TimeColsView'\nimport { DayTimeCols } from './DayTimeCols'\nimport { buildSlatMetas } from './time-slat-meta'\n\nexport class DayTimeColsView extends TimeColsView {\n  private buildTimeColsModel = memoize(buildTimeColsModel)\n  private buildSlatMetas = memoize(buildSlatMetas)\n\n  render() {\n    let { options, dateEnv, dateProfileGenerator } = this.context\n    let { props } = this\n    let { dateProfile } = props\n    let dayTableModel = this.buildTimeColsModel(dateProfile, dateProfileGenerator)\n    let splitProps = this.allDaySplitter.splitProps(props)\n    let slatMetas = this.buildSlatMetas(\n      dateProfile.slotMinTime,\n      dateProfile.slotMaxTime,\n      options.slotLabelInterval,\n      options.slotDuration,\n      dateEnv,\n    )\n    let { dayMinWidth } = options\n    let hasAttachedAxis = !dayMinWidth\n    let hasDetachedAxis = dayMinWidth\n\n    let headerContent = options.dayHeaders && (\n      <DayHeader\n        dates={dayTableModel.headerDates}\n        dateProfile={dateProfile}\n        datesRepDistinctDays\n        renderIntro={hasAttachedAxis ? this.renderHeadAxis : null}\n      />\n    )\n\n    let allDayContent = (options.allDaySlot !== false) && ((contentArg: ChunkContentCallbackArgs) => (\n      <DayTable\n        {...splitProps.allDay}\n        dateProfile={dateProfile}\n        dayTableModel={dayTableModel}\n        nextDayThreshold={options.nextDayThreshold}\n        tableMinWidth={contentArg.tableMinWidth}\n        colGroupNode={contentArg.tableColGroupNode}\n        renderRowIntro={hasAttachedAxis ? this.renderTableRowAxis : null}\n        showWeekNumbers={false}\n        expandRows={false}\n        headerAlignElRef={this.headerElRef}\n        clientWidth={contentArg.clientWidth}\n        clientHeight={contentArg.clientHeight}\n        forPrint={props.forPrint}\n        {...this.getAllDayMaxEventProps()}\n      />\n    ))\n\n    let timeGridContent = (contentArg: ChunkContentCallbackArgs) => (\n      <DayTimeCols\n        {...splitProps.timed}\n        dayTableModel={dayTableModel}\n        dateProfile={dateProfile}\n        axis={hasAttachedAxis}\n        slotDuration={options.slotDuration}\n        slatMetas={slatMetas}\n        forPrint={props.forPrint}\n        tableColGroupNode={contentArg.tableColGroupNode}\n        tableMinWidth={contentArg.tableMinWidth}\n        clientWidth={contentArg.clientWidth}\n        clientHeight={contentArg.clientHeight}\n        onSlatCoords={this.handleSlatCoords}\n        expandRows={contentArg.expandRows}\n        onScrollTopRequest={this.handleScrollTopRequest}\n      />\n    )\n\n    return hasDetachedAxis\n      ? this.renderHScrollLayout(\n        headerContent,\n        allDayContent,\n        timeGridContent,\n        dayTableModel.colCnt,\n        dayMinWidth,\n        slatMetas,\n        this.state.slatCoords,\n      )\n      : this.renderSimpleLayout(\n        headerContent,\n        allDayContent,\n        timeGridContent,\n      )\n  }\n}\n\nexport function buildTimeColsModel(dateProfile: DateProfile, dateProfileGenerator: DateProfileGenerator) {\n  let daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator)\n\n  return new DayTableModel(daySeries, false)\n}\n","export const OPTION_REFINERS = {\n  allDaySlot: Boolean,\n}\n","import { createPlugin } from '@fullcalendar/common'\nimport { TimeColsView } from './TimeColsView'\nimport { DayTimeColsView, buildTimeColsModel } from './DayTimeColsView'\nimport { TimeColsSeg } from './TimeColsSeg'\nimport { DayTimeCols, buildDayRanges } from './DayTimeCols'\nimport { DayTimeColsSlicer } from './DayTimeColsSlicer'\nimport { OPTION_REFINERS } from './options'\nimport './options-declare'\nimport './main.css'\n\nexport { DayTimeCols, DayTimeColsView, TimeColsView, buildTimeColsModel, buildDayRanges, DayTimeColsSlicer, TimeColsSeg }\nexport { TimeCols } from './TimeCols'\nexport { TimeSlatMeta, buildSlatMetas } from './time-slat-meta'\nexport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\n\nexport default createPlugin({\n  initialView: 'timeGridWeek',\n  optionRefiners: OPTION_REFINERS,\n  views: {\n\n    timeGrid: {\n      component: DayTimeColsView,\n      usesMinMaxTime: true, // indicates that slotMinTime/slotMaxTime affects rendering\n      allDaySlot: true,\n      slotDuration: '00:30:00',\n      slotEventOverlap: true, // a bad name. confused with overlap/constraint system\n    },\n\n    timeGridDay: {\n      type: 'timeGrid',\n      duration: { days: 1 },\n    },\n\n    timeGridWeek: {\n      type: 'timeGrid',\n      duration: { weeks: 1 },\n    },\n\n  },\n})\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}